
class TDoc(object):
    def __init__(self, name,):
        self.name = name
        self.includes = []
        self.namespaces = []
        self.enums = []
        self.structs = []
        self.exceptions = []
        self.services = []
    def include(self,i):
        self.includes.append(i)

    def namespace(self, lang, namespace):
        self.namespaces.append((lang, namespace))

    def enum(self, e):
        self.enums.append(e)

    def struct(self, s):
        self.structs.append(s)

    def exception(self,s):
        self.exceptions.append(s)

    def service(self,s):
        self.services.append(s)

    def pp(self):
        s = "/* This thrift file has been autogenerated */\n\n" 
        s += "\n".join([('include "%s"\n' % i) for i in
                    self.includes ])

        s += "\n".join([("namespace " + lang + " " + ns) for (lang, ns) in
                    self.namespaces ])

        s += "\n\n/* enums: */\n"
        s += "\n".join([e.pp() for e in self.enums ])

        s += "\n\n/* structs: */\n"
        s += "\n".join([e.pp() for e in self.structs ])

        s += "\n\n/* exceptions : */\n"
        s += "\n".join([e.pp() for e in self.exceptions ])

        s += "\n\n/* services: */\n"
        s += "\n".join([e.pp() for e in self.services ])
        return s

class TEnumEntry(object):
    def __init__(self, name):
        self.name = name
    def pp(self):
        return self.name.upper()

class TEnumEntryValue(object):
    def __init__(self, name, value):
        self.name = name
        self.value = value
    def pp(self):
        return ("%s = %d" % (self.name.upper(), self.value))

class TEnum(object):
    def __init__(self, typename):
        self.typename = typename
        self.values = []

    def entry(self, name, value=None):
        if value == None:
            self.values.append(TEnumEntry(name))
        else:
            self.values.append(TEnumEntryValue(name,value))

    def pp(self):
        body = (",\n  ").join([ v.pp() for v in self.values ])
        return ("enum %s {\n  %s\n}\n" % (self.typename , body))

class TTyped(object):
    def __init__(self,typename):
        self.typename = typename

class TAtomField(object):
    def __init__(self,index, name, fieldtype):
        self.index = index
        self.name = name
        self.fieldtype = fieldtype
    def pp(self):
        return ("%d: %s %s" % (self.index, self.fieldtype, self.name))

class TListField(object):
    def __init__(self, index, name, fieldtype):
        self.index = index
        self.name = name
        self.fieldtype = fieldtype
    def pp(self):
        return ("%d: list<%s> %s" % (self.index, self.fieldtype, self.name))

class TStruct(object):
    def __init__(self, typename):
        self.typename = typename
        self.fieldindex = 0
        self.fields = []
    def atom_field(self, name, fieldtype):
        idx = self.fieldindex + 1
        self.fieldindex = idx
        self.fields.append(TAtomField(idx, name, fieldtype))
    def list_field(self, name, fieldtype):
        idx = self.fieldindex + 1
        self.fieldindex = idx
        self.fields.append(TListField(idx, name, fieldtype))
    def pp(self):
        body = (",\n  ").join([ f.pp() for f in self.fields ])
        return ("struct %s {\n  %s\n}\n" % (self.typename, body))

class TList(object):
    def __init__(self, base):
        self.typename = "list<%s>" % base.typename

class TMap(object):
    def __init__(self,fro,to):
        self.typename = "map<%s,%s>" % (fro.typename, to.typename)

class TException(TStruct):
    def pp(self):
        body = (",\n  ").join([ f.pp() for f in self.fields ])
        return ("exception %s {\n  %s\n}\n" % (self.typename, body))

class TMethodArg(object):
    def __init__(self,name,typeobj,idx):
        self.name = name
        self.typeobj = typeobj
        self.idx = idx
    def pp(self):
        return ("%d: %s %s" % (self.idx, self.typeobj.typename, self.name))


class TMethod(object):
    def __init__(self,name,returntype):
        self.name = name
        self.returntype = returntype
        self.argindex = 0
        self.args = []
        self.exceptindex = 0;
        self.excepts = []
    def arg(self,typeobj,name):
        idx = self.argindex + 1
        self.argindex = idx
        self.args.append(TMethodArg(name,typeobj,idx))
    def throws(self,exceptionobj,name):
        idx = self.exceptindex + 1
        self.exceptindex = idx
        self.excepts.append(TMethodArg(name,exceptionobj,idx))
    def pp(self):
        aa = (",").join([ a.pp() for a in self.args ])
        res = "%s %s(%s)" % (self.returntype.typename, self.name, aa)
        if self.exceptindex > 0:
            es = ((",").join([ e.pp() for e in self.excepts ]))
            res += " throws (%s)" % es
        return res
class TVoidMethod(TMethod):
    def __init__(self,name):
        super(TVoidMethod,self).__init__(name,TTyped("void"))

class TService(object):
    def __init__(self,name):
        self.name = name
        self.methods = []
        self.parent = None
    def extends(self,parent):
        self.parent = parent
    def method(self,m):
        self.methods.append(m)
    def pp(self):
        name = self.name
        if self.parent:
            name += "  extends " + self.parent
        body = (",\n  ").join([ m.pp() for m in self.methods ])
        return ("service %s {\n  %s\n}\n" % (name, body))


