/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef ardupilotmega_TYPES_H
#define ardupilotmega_TYPES_H

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include "common_types.h"


namespace mavlink { namespace thrift {

struct ArdupilotmegaMessageTypes {
  enum type {
    HEARTBEAT = 0,
    SYS_STATUS = 1,
    SYSTEM_TIME = 2,
    PING = 3,
    CHANGE_OPERATOR_CONTROL = 4,
    CHANGE_OPERATOR_CONTROL_ACK = 5,
    AUTH_KEY = 6,
    SET_MODE = 7,
    PARAM_REQUEST_READ = 8,
    PARAM_REQUEST_LIST = 9,
    PARAM_VALUE = 10,
    PARAM_SET = 11,
    GPS_RAW_INT = 12,
    GPS_STATUS = 13,
    SCALED_IMU = 14,
    RAW_IMU = 15,
    RAW_PRESSURE = 16,
    SCALED_PRESSURE = 17,
    ATTITUDE = 18,
    ATTITUDE_QUATERNION = 19,
    LOCAL_POSITION_NED = 20,
    GLOBAL_POSITION_INT = 21,
    RC_CHANNELS_SCALED = 22,
    RC_CHANNELS_RAW = 23,
    SERVO_OUTPUT_RAW = 24,
    MISSION_REQUEST_PARTIAL_LIST = 25,
    MISSION_WRITE_PARTIAL_LIST = 26,
    MISSION_ITEM = 27,
    MISSION_REQUEST = 28,
    MISSION_SET_CURRENT = 29,
    MISSION_CURRENT = 30,
    MISSION_REQUEST_LIST = 31,
    MISSION_COUNT = 32,
    MISSION_CLEAR_ALL = 33,
    MISSION_ITEM_REACHED = 34,
    MISSION_ACK = 35,
    SET_GPS_GLOBAL_ORIGIN = 36,
    GPS_GLOBAL_ORIGIN = 37,
    SET_LOCAL_POSITION_SETPOINT = 38,
    LOCAL_POSITION_SETPOINT = 39,
    GLOBAL_POSITION_SETPOINT_INT = 40,
    SET_GLOBAL_POSITION_SETPOINT_INT = 41,
    SAFETY_SET_ALLOWED_AREA = 42,
    SAFETY_ALLOWED_AREA = 43,
    SET_ROLL_PITCH_YAW_THRUST = 44,
    SET_ROLL_PITCH_YAW_SPEED_THRUST = 45,
    ROLL_PITCH_YAW_THRUST_SETPOINT = 46,
    ROLL_PITCH_YAW_SPEED_THRUST_SETPOINT = 47,
    SET_QUAD_MOTORS_SETPOINT = 48,
    SET_QUAD_SWARM_ROLL_PITCH_YAW_THRUST = 49,
    NAV_CONTROLLER_OUTPUT = 50,
    SET_QUAD_SWARM_LED_ROLL_PITCH_YAW_THRUST = 51,
    STATE_CORRECTION = 52,
    REQUEST_DATA_STREAM = 53,
    DATA_STREAM = 54,
    MANUAL_CONTROL = 55,
    RC_CHANNELS_OVERRIDE = 56,
    VFR_HUD = 57,
    COMMAND_LONG = 58,
    COMMAND_ACK = 59,
    ROLL_PITCH_YAW_RATES_THRUST_SETPOINT = 60,
    MANUAL_SETPOINT = 61,
    LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET = 62,
    HIL_STATE = 63,
    HIL_CONTROLS = 64,
    HIL_RC_INPUTS_RAW = 65,
    OPTICAL_FLOW = 66,
    GLOBAL_VISION_POSITION_ESTIMATE = 67,
    VISION_POSITION_ESTIMATE = 68,
    VISION_SPEED_ESTIMATE = 69,
    VICON_POSITION_ESTIMATE = 70,
    HIGHRES_IMU = 71,
    OMNIDIRECTIONAL_FLOW = 72,
    FILE_TRANSFER_START = 73,
    FILE_TRANSFER_DIR_LIST = 74,
    FILE_TRANSFER_RES = 75,
    BATTERY_STATUS = 76,
    SETPOINT_8DOF = 77,
    SETPOINT_6DOF = 78,
    MEMORY_VECT = 79,
    DEBUG_VECT = 80,
    NAMED_VALUE_FLOAT = 81,
    NAMED_VALUE_INT = 82,
    STATUSTEXT = 83,
    DEBUG = 84,
    SENSOR_OFFSETS = 85,
    SET_MAG_OFFSETS = 86,
    MEMINFO = 87,
    AP_ADC = 88,
    DIGICAM_CONFIGURE = 89,
    DIGICAM_CONTROL = 90,
    MOUNT_CONFIGURE = 91,
    MOUNT_CONTROL = 92,
    MOUNT_STATUS = 93,
    FENCE_POINT = 94,
    FENCE_FETCH_POINT = 95,
    FENCE_STATUS = 96,
    AHRS = 97,
    SIMSTATE = 98,
    HWSTATUS = 99,
    RADIO = 100,
    LIMITS_STATUS = 101,
    WIND = 102,
    DATA16 = 103,
    DATA32 = 104,
    DATA64 = 105,
    DATA96 = 106,
    RANGEFINDER = 107
  };
};

extern const std::map<int, const char*> _ArdupilotmegaMessageTypes_VALUES_TO_NAMES;

struct Mount_mode {
  enum type {
    RETRACT = 0,
    NEUTRAL = 1,
    MAVLINK_TARGETING = 2,
    RC_TARGETING = 3,
    GPS_POINT = 4
  };
};

extern const std::map<int, const char*> _Mount_mode_VALUES_TO_NAMES;

struct Cmd {
  enum type {
    NAV_WAYPOINT = 16,
    NAV_LOITER_UNLIM = 17,
    NAV_LOITER_TURNS = 18,
    NAV_LOITER_TIME = 19,
    NAV_RETURN_TO_LAUNCH = 20,
    NAV_LAND = 21,
    NAV_TAKEOFF = 22,
    NAV_ROI = 80,
    NAV_PATHPLANNING = 81,
    NAV_LAST = 95,
    CONDITION_DELAY = 112,
    CONDITION_CHANGE_ALT = 113,
    CONDITION_DISTANCE = 114,
    CONDITION_YAW = 115,
    CONDITION_LAST = 159,
    DO_SET_MODE = 176,
    DO_JUMP = 177,
    DO_CHANGE_SPEED = 178,
    DO_SET_HOME = 179,
    DO_SET_PARAMETER = 180,
    DO_SET_RELAY = 181,
    DO_REPEAT_RELAY = 182,
    DO_SET_SERVO = 183,
    DO_REPEAT_SERVO = 184,
    DO_CONTROL_VIDEO = 200,
    DO_DIGICAM_CONFIGURE = 202,
    DO_DIGICAM_CONTROL = 203,
    DO_MOUNT_CONFIGURE = 204,
    DO_MOUNT_CONTROL = 205,
    DO_LAST = 240,
    PREFLIGHT_CALIBRATION = 241,
    PREFLIGHT_SET_SENSOR_OFFSETS = 242,
    PREFLIGHT_STORAGE = 245,
    PREFLIGHT_REBOOT_SHUTDOWN = 246,
    OVERRIDE_GOTO = 252,
    MISSION_START = 300,
    COMPONENT_ARM_DISARM = 400
  };
};

extern const std::map<int, const char*> _Cmd_VALUES_TO_NAMES;

struct Fence_action {
  enum type {
    NONE = 0,
    GUIDED = 1,
    REPORT = 2
  };
};

extern const std::map<int, const char*> _Fence_action_VALUES_TO_NAMES;

struct Fence_breach {
  enum type {
    NONE = 0,
    MINALT = 1,
    MAXALT = 2,
    BOUNDARY = 3
  };
};

extern const std::map<int, const char*> _Fence_breach_VALUES_TO_NAMES;

struct Limits_state {
  enum type {
    INIT = 0,
    DISABLED = 1,
    ENABLED = 2,
    TRIGGERED = 3,
    RECOVERING = 4,
    RECOVERED = 5,
    STATE_ENUM_END = 6
  };
};

extern const std::map<int, const char*> _Limits_state_VALUES_TO_NAMES;

struct Limit_module {
  enum type {
    GPSLOCK = 1,
    GEOFENCE = 2,
    ALTITUDE = 4,
    MODULE_ENUM_END = 5
  };
};

extern const std::map<int, const char*> _Limit_module_VALUES_TO_NAMES;

typedef struct _SensorOffsets__isset {
  _SensorOffsets__isset() : mag_ofs_x(false), mag_ofs_y(false), mag_ofs_z(false), mag_declination(false), raw_press(false), raw_temp(false), gyro_cal_x(false), gyro_cal_y(false), gyro_cal_z(false), accel_cal_x(false), accel_cal_y(false), accel_cal_z(false) {}
  bool mag_ofs_x;
  bool mag_ofs_y;
  bool mag_ofs_z;
  bool mag_declination;
  bool raw_press;
  bool raw_temp;
  bool gyro_cal_x;
  bool gyro_cal_y;
  bool gyro_cal_z;
  bool accel_cal_x;
  bool accel_cal_y;
  bool accel_cal_z;
} _SensorOffsets__isset;

class SensorOffsets {
 public:

  static const char* ascii_fingerprint; // = "5C8FF195E58A59EDF3556BECA79CE081";
  static const uint8_t binary_fingerprint[16]; // = {0x5C,0x8F,0xF1,0x95,0xE5,0x8A,0x59,0xED,0xF3,0x55,0x6B,0xEC,0xA7,0x9C,0xE0,0x81};

  SensorOffsets() : mag_ofs_x(0), mag_ofs_y(0), mag_ofs_z(0), mag_declination(0), raw_press(0), raw_temp(0), gyro_cal_x(0), gyro_cal_y(0), gyro_cal_z(0), accel_cal_x(0), accel_cal_y(0), accel_cal_z(0) {
  }

  virtual ~SensorOffsets() throw() {}

  int16_t mag_ofs_x;
  int16_t mag_ofs_y;
  int16_t mag_ofs_z;
  double mag_declination;
  int32_t raw_press;
  int32_t raw_temp;
  double gyro_cal_x;
  double gyro_cal_y;
  double gyro_cal_z;
  double accel_cal_x;
  double accel_cal_y;
  double accel_cal_z;

  _SensorOffsets__isset __isset;

  void __set_mag_ofs_x(const int16_t val) {
    mag_ofs_x = val;
  }

  void __set_mag_ofs_y(const int16_t val) {
    mag_ofs_y = val;
  }

  void __set_mag_ofs_z(const int16_t val) {
    mag_ofs_z = val;
  }

  void __set_mag_declination(const double val) {
    mag_declination = val;
  }

  void __set_raw_press(const int32_t val) {
    raw_press = val;
  }

  void __set_raw_temp(const int32_t val) {
    raw_temp = val;
  }

  void __set_gyro_cal_x(const double val) {
    gyro_cal_x = val;
  }

  void __set_gyro_cal_y(const double val) {
    gyro_cal_y = val;
  }

  void __set_gyro_cal_z(const double val) {
    gyro_cal_z = val;
  }

  void __set_accel_cal_x(const double val) {
    accel_cal_x = val;
  }

  void __set_accel_cal_y(const double val) {
    accel_cal_y = val;
  }

  void __set_accel_cal_z(const double val) {
    accel_cal_z = val;
  }

  bool operator == (const SensorOffsets & rhs) const
  {
    if (!(mag_ofs_x == rhs.mag_ofs_x))
      return false;
    if (!(mag_ofs_y == rhs.mag_ofs_y))
      return false;
    if (!(mag_ofs_z == rhs.mag_ofs_z))
      return false;
    if (!(mag_declination == rhs.mag_declination))
      return false;
    if (!(raw_press == rhs.raw_press))
      return false;
    if (!(raw_temp == rhs.raw_temp))
      return false;
    if (!(gyro_cal_x == rhs.gyro_cal_x))
      return false;
    if (!(gyro_cal_y == rhs.gyro_cal_y))
      return false;
    if (!(gyro_cal_z == rhs.gyro_cal_z))
      return false;
    if (!(accel_cal_x == rhs.accel_cal_x))
      return false;
    if (!(accel_cal_y == rhs.accel_cal_y))
      return false;
    if (!(accel_cal_z == rhs.accel_cal_z))
      return false;
    return true;
  }
  bool operator != (const SensorOffsets &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SensorOffsets & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(SensorOffsets &a, SensorOffsets &b);

typedef struct _SetMagOffsets__isset {
  _SetMagOffsets__isset() : target_system(false), target_component(false), mag_ofs_x(false), mag_ofs_y(false), mag_ofs_z(false) {}
  bool target_system;
  bool target_component;
  bool mag_ofs_x;
  bool mag_ofs_y;
  bool mag_ofs_z;
} _SetMagOffsets__isset;

class SetMagOffsets {
 public:

  static const char* ascii_fingerprint; // = "99A3CB793D08BB7B4ACF4E3955FADD82";
  static const uint8_t binary_fingerprint[16]; // = {0x99,0xA3,0xCB,0x79,0x3D,0x08,0xBB,0x7B,0x4A,0xCF,0x4E,0x39,0x55,0xFA,0xDD,0x82};

  SetMagOffsets() : target_system(0), target_component(0), mag_ofs_x(0), mag_ofs_y(0), mag_ofs_z(0) {
  }

  virtual ~SetMagOffsets() throw() {}

  int8_t target_system;
  int8_t target_component;
  int16_t mag_ofs_x;
  int16_t mag_ofs_y;
  int16_t mag_ofs_z;

  _SetMagOffsets__isset __isset;

  void __set_target_system(const int8_t val) {
    target_system = val;
  }

  void __set_target_component(const int8_t val) {
    target_component = val;
  }

  void __set_mag_ofs_x(const int16_t val) {
    mag_ofs_x = val;
  }

  void __set_mag_ofs_y(const int16_t val) {
    mag_ofs_y = val;
  }

  void __set_mag_ofs_z(const int16_t val) {
    mag_ofs_z = val;
  }

  bool operator == (const SetMagOffsets & rhs) const
  {
    if (!(target_system == rhs.target_system))
      return false;
    if (!(target_component == rhs.target_component))
      return false;
    if (!(mag_ofs_x == rhs.mag_ofs_x))
      return false;
    if (!(mag_ofs_y == rhs.mag_ofs_y))
      return false;
    if (!(mag_ofs_z == rhs.mag_ofs_z))
      return false;
    return true;
  }
  bool operator != (const SetMagOffsets &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SetMagOffsets & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(SetMagOffsets &a, SetMagOffsets &b);

typedef struct _Meminfo__isset {
  _Meminfo__isset() : brkval(false), freemem(false) {}
  bool brkval;
  bool freemem;
} _Meminfo__isset;

class Meminfo {
 public:

  static const char* ascii_fingerprint; // = "C88FB7958D86460D03E699333A272947";
  static const uint8_t binary_fingerprint[16]; // = {0xC8,0x8F,0xB7,0x95,0x8D,0x86,0x46,0x0D,0x03,0xE6,0x99,0x33,0x3A,0x27,0x29,0x47};

  Meminfo() : brkval(0), freemem(0) {
  }

  virtual ~Meminfo() throw() {}

  int16_t brkval;
  int16_t freemem;

  _Meminfo__isset __isset;

  void __set_brkval(const int16_t val) {
    brkval = val;
  }

  void __set_freemem(const int16_t val) {
    freemem = val;
  }

  bool operator == (const Meminfo & rhs) const
  {
    if (!(brkval == rhs.brkval))
      return false;
    if (!(freemem == rhs.freemem))
      return false;
    return true;
  }
  bool operator != (const Meminfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Meminfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Meminfo &a, Meminfo &b);

typedef struct _ApAdc__isset {
  _ApAdc__isset() : adc1(false), adc2(false), adc3(false), adc4(false), adc5(false), adc6(false) {}
  bool adc1;
  bool adc2;
  bool adc3;
  bool adc4;
  bool adc5;
  bool adc6;
} _ApAdc__isset;

class ApAdc {
 public:

  static const char* ascii_fingerprint; // = "4BFEB2A4F7E3C310FEEE505404210134";
  static const uint8_t binary_fingerprint[16]; // = {0x4B,0xFE,0xB2,0xA4,0xF7,0xE3,0xC3,0x10,0xFE,0xEE,0x50,0x54,0x04,0x21,0x01,0x34};

  ApAdc() : adc1(0), adc2(0), adc3(0), adc4(0), adc5(0), adc6(0) {
  }

  virtual ~ApAdc() throw() {}

  int16_t adc1;
  int16_t adc2;
  int16_t adc3;
  int16_t adc4;
  int16_t adc5;
  int16_t adc6;

  _ApAdc__isset __isset;

  void __set_adc1(const int16_t val) {
    adc1 = val;
  }

  void __set_adc2(const int16_t val) {
    adc2 = val;
  }

  void __set_adc3(const int16_t val) {
    adc3 = val;
  }

  void __set_adc4(const int16_t val) {
    adc4 = val;
  }

  void __set_adc5(const int16_t val) {
    adc5 = val;
  }

  void __set_adc6(const int16_t val) {
    adc6 = val;
  }

  bool operator == (const ApAdc & rhs) const
  {
    if (!(adc1 == rhs.adc1))
      return false;
    if (!(adc2 == rhs.adc2))
      return false;
    if (!(adc3 == rhs.adc3))
      return false;
    if (!(adc4 == rhs.adc4))
      return false;
    if (!(adc5 == rhs.adc5))
      return false;
    if (!(adc6 == rhs.adc6))
      return false;
    return true;
  }
  bool operator != (const ApAdc &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ApAdc & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(ApAdc &a, ApAdc &b);

typedef struct _DigicamConfigure__isset {
  _DigicamConfigure__isset() : target_system(false), target_component(false), mode(false), shutter_speed(false), aperture(false), iso(false), exposure_type(false), command_id(false), engine_cut_off(false), extra_param(false), extra_value(false) {}
  bool target_system;
  bool target_component;
  bool mode;
  bool shutter_speed;
  bool aperture;
  bool iso;
  bool exposure_type;
  bool command_id;
  bool engine_cut_off;
  bool extra_param;
  bool extra_value;
} _DigicamConfigure__isset;

class DigicamConfigure {
 public:

  static const char* ascii_fingerprint; // = "083C6024F6C6CCB2309FE66335D221CB";
  static const uint8_t binary_fingerprint[16]; // = {0x08,0x3C,0x60,0x24,0xF6,0xC6,0xCC,0xB2,0x30,0x9F,0xE6,0x63,0x35,0xD2,0x21,0xCB};

  DigicamConfigure() : target_system(0), target_component(0), mode(0), shutter_speed(0), aperture(0), iso(0), exposure_type(0), command_id(0), engine_cut_off(0), extra_param(0), extra_value(0) {
  }

  virtual ~DigicamConfigure() throw() {}

  int8_t target_system;
  int8_t target_component;
  int8_t mode;
  int16_t shutter_speed;
  int8_t aperture;
  int8_t iso;
  int8_t exposure_type;
  int8_t command_id;
  int8_t engine_cut_off;
  int8_t extra_param;
  double extra_value;

  _DigicamConfigure__isset __isset;

  void __set_target_system(const int8_t val) {
    target_system = val;
  }

  void __set_target_component(const int8_t val) {
    target_component = val;
  }

  void __set_mode(const int8_t val) {
    mode = val;
  }

  void __set_shutter_speed(const int16_t val) {
    shutter_speed = val;
  }

  void __set_aperture(const int8_t val) {
    aperture = val;
  }

  void __set_iso(const int8_t val) {
    iso = val;
  }

  void __set_exposure_type(const int8_t val) {
    exposure_type = val;
  }

  void __set_command_id(const int8_t val) {
    command_id = val;
  }

  void __set_engine_cut_off(const int8_t val) {
    engine_cut_off = val;
  }

  void __set_extra_param(const int8_t val) {
    extra_param = val;
  }

  void __set_extra_value(const double val) {
    extra_value = val;
  }

  bool operator == (const DigicamConfigure & rhs) const
  {
    if (!(target_system == rhs.target_system))
      return false;
    if (!(target_component == rhs.target_component))
      return false;
    if (!(mode == rhs.mode))
      return false;
    if (!(shutter_speed == rhs.shutter_speed))
      return false;
    if (!(aperture == rhs.aperture))
      return false;
    if (!(iso == rhs.iso))
      return false;
    if (!(exposure_type == rhs.exposure_type))
      return false;
    if (!(command_id == rhs.command_id))
      return false;
    if (!(engine_cut_off == rhs.engine_cut_off))
      return false;
    if (!(extra_param == rhs.extra_param))
      return false;
    if (!(extra_value == rhs.extra_value))
      return false;
    return true;
  }
  bool operator != (const DigicamConfigure &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DigicamConfigure & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(DigicamConfigure &a, DigicamConfigure &b);

typedef struct _DigicamControl__isset {
  _DigicamControl__isset() : target_system(false), target_component(false), session(false), zoom_pos(false), zoom_step(false), focus_lock(false), shot(false), command_id(false), extra_param(false), extra_value(false) {}
  bool target_system;
  bool target_component;
  bool session;
  bool zoom_pos;
  bool zoom_step;
  bool focus_lock;
  bool shot;
  bool command_id;
  bool extra_param;
  bool extra_value;
} _DigicamControl__isset;

class DigicamControl {
 public:

  static const char* ascii_fingerprint; // = "379FC86FB4BB211EF292113F1DBBEB9D";
  static const uint8_t binary_fingerprint[16]; // = {0x37,0x9F,0xC8,0x6F,0xB4,0xBB,0x21,0x1E,0xF2,0x92,0x11,0x3F,0x1D,0xBB,0xEB,0x9D};

  DigicamControl() : target_system(0), target_component(0), session(0), zoom_pos(0), zoom_step(0), focus_lock(0), shot(0), command_id(0), extra_param(0), extra_value(0) {
  }

  virtual ~DigicamControl() throw() {}

  int8_t target_system;
  int8_t target_component;
  int8_t session;
  int8_t zoom_pos;
  int8_t zoom_step;
  int8_t focus_lock;
  int8_t shot;
  int8_t command_id;
  int8_t extra_param;
  double extra_value;

  _DigicamControl__isset __isset;

  void __set_target_system(const int8_t val) {
    target_system = val;
  }

  void __set_target_component(const int8_t val) {
    target_component = val;
  }

  void __set_session(const int8_t val) {
    session = val;
  }

  void __set_zoom_pos(const int8_t val) {
    zoom_pos = val;
  }

  void __set_zoom_step(const int8_t val) {
    zoom_step = val;
  }

  void __set_focus_lock(const int8_t val) {
    focus_lock = val;
  }

  void __set_shot(const int8_t val) {
    shot = val;
  }

  void __set_command_id(const int8_t val) {
    command_id = val;
  }

  void __set_extra_param(const int8_t val) {
    extra_param = val;
  }

  void __set_extra_value(const double val) {
    extra_value = val;
  }

  bool operator == (const DigicamControl & rhs) const
  {
    if (!(target_system == rhs.target_system))
      return false;
    if (!(target_component == rhs.target_component))
      return false;
    if (!(session == rhs.session))
      return false;
    if (!(zoom_pos == rhs.zoom_pos))
      return false;
    if (!(zoom_step == rhs.zoom_step))
      return false;
    if (!(focus_lock == rhs.focus_lock))
      return false;
    if (!(shot == rhs.shot))
      return false;
    if (!(command_id == rhs.command_id))
      return false;
    if (!(extra_param == rhs.extra_param))
      return false;
    if (!(extra_value == rhs.extra_value))
      return false;
    return true;
  }
  bool operator != (const DigicamControl &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DigicamControl & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(DigicamControl &a, DigicamControl &b);

typedef struct _MountConfigure__isset {
  _MountConfigure__isset() : target_system(false), target_component(false), mount_mode(false), stab_roll(false), stab_pitch(false), stab_yaw(false) {}
  bool target_system;
  bool target_component;
  bool mount_mode;
  bool stab_roll;
  bool stab_pitch;
  bool stab_yaw;
} _MountConfigure__isset;

class MountConfigure {
 public:

  static const char* ascii_fingerprint; // = "0F8D4306D81F0F21E94B977AA746DB78";
  static const uint8_t binary_fingerprint[16]; // = {0x0F,0x8D,0x43,0x06,0xD8,0x1F,0x0F,0x21,0xE9,0x4B,0x97,0x7A,0xA7,0x46,0xDB,0x78};

  MountConfigure() : target_system(0), target_component(0), mount_mode(0), stab_roll(0), stab_pitch(0), stab_yaw(0) {
  }

  virtual ~MountConfigure() throw() {}

  int8_t target_system;
  int8_t target_component;
  int8_t mount_mode;
  int8_t stab_roll;
  int8_t stab_pitch;
  int8_t stab_yaw;

  _MountConfigure__isset __isset;

  void __set_target_system(const int8_t val) {
    target_system = val;
  }

  void __set_target_component(const int8_t val) {
    target_component = val;
  }

  void __set_mount_mode(const int8_t val) {
    mount_mode = val;
  }

  void __set_stab_roll(const int8_t val) {
    stab_roll = val;
  }

  void __set_stab_pitch(const int8_t val) {
    stab_pitch = val;
  }

  void __set_stab_yaw(const int8_t val) {
    stab_yaw = val;
  }

  bool operator == (const MountConfigure & rhs) const
  {
    if (!(target_system == rhs.target_system))
      return false;
    if (!(target_component == rhs.target_component))
      return false;
    if (!(mount_mode == rhs.mount_mode))
      return false;
    if (!(stab_roll == rhs.stab_roll))
      return false;
    if (!(stab_pitch == rhs.stab_pitch))
      return false;
    if (!(stab_yaw == rhs.stab_yaw))
      return false;
    return true;
  }
  bool operator != (const MountConfigure &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MountConfigure & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(MountConfigure &a, MountConfigure &b);

typedef struct _MountControl__isset {
  _MountControl__isset() : target_system(false), target_component(false), input_a(false), input_b(false), input_c(false), save_position(false) {}
  bool target_system;
  bool target_component;
  bool input_a;
  bool input_b;
  bool input_c;
  bool save_position;
} _MountControl__isset;

class MountControl {
 public:

  static const char* ascii_fingerprint; // = "F2D4822E3C18F828EEAC2C38275443E1";
  static const uint8_t binary_fingerprint[16]; // = {0xF2,0xD4,0x82,0x2E,0x3C,0x18,0xF8,0x28,0xEE,0xAC,0x2C,0x38,0x27,0x54,0x43,0xE1};

  MountControl() : target_system(0), target_component(0), input_a(0), input_b(0), input_c(0), save_position(0) {
  }

  virtual ~MountControl() throw() {}

  int8_t target_system;
  int8_t target_component;
  int32_t input_a;
  int32_t input_b;
  int32_t input_c;
  int8_t save_position;

  _MountControl__isset __isset;

  void __set_target_system(const int8_t val) {
    target_system = val;
  }

  void __set_target_component(const int8_t val) {
    target_component = val;
  }

  void __set_input_a(const int32_t val) {
    input_a = val;
  }

  void __set_input_b(const int32_t val) {
    input_b = val;
  }

  void __set_input_c(const int32_t val) {
    input_c = val;
  }

  void __set_save_position(const int8_t val) {
    save_position = val;
  }

  bool operator == (const MountControl & rhs) const
  {
    if (!(target_system == rhs.target_system))
      return false;
    if (!(target_component == rhs.target_component))
      return false;
    if (!(input_a == rhs.input_a))
      return false;
    if (!(input_b == rhs.input_b))
      return false;
    if (!(input_c == rhs.input_c))
      return false;
    if (!(save_position == rhs.save_position))
      return false;
    return true;
  }
  bool operator != (const MountControl &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MountControl & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(MountControl &a, MountControl &b);

typedef struct _MountStatus__isset {
  _MountStatus__isset() : target_system(false), target_component(false), pointing_a(false), pointing_b(false), pointing_c(false) {}
  bool target_system;
  bool target_component;
  bool pointing_a;
  bool pointing_b;
  bool pointing_c;
} _MountStatus__isset;

class MountStatus {
 public:

  static const char* ascii_fingerprint; // = "1919976FBA738E4D68959537BAB9AED6";
  static const uint8_t binary_fingerprint[16]; // = {0x19,0x19,0x97,0x6F,0xBA,0x73,0x8E,0x4D,0x68,0x95,0x95,0x37,0xBA,0xB9,0xAE,0xD6};

  MountStatus() : target_system(0), target_component(0), pointing_a(0), pointing_b(0), pointing_c(0) {
  }

  virtual ~MountStatus() throw() {}

  int8_t target_system;
  int8_t target_component;
  int32_t pointing_a;
  int32_t pointing_b;
  int32_t pointing_c;

  _MountStatus__isset __isset;

  void __set_target_system(const int8_t val) {
    target_system = val;
  }

  void __set_target_component(const int8_t val) {
    target_component = val;
  }

  void __set_pointing_a(const int32_t val) {
    pointing_a = val;
  }

  void __set_pointing_b(const int32_t val) {
    pointing_b = val;
  }

  void __set_pointing_c(const int32_t val) {
    pointing_c = val;
  }

  bool operator == (const MountStatus & rhs) const
  {
    if (!(target_system == rhs.target_system))
      return false;
    if (!(target_component == rhs.target_component))
      return false;
    if (!(pointing_a == rhs.pointing_a))
      return false;
    if (!(pointing_b == rhs.pointing_b))
      return false;
    if (!(pointing_c == rhs.pointing_c))
      return false;
    return true;
  }
  bool operator != (const MountStatus &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MountStatus & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(MountStatus &a, MountStatus &b);

typedef struct _FencePoint__isset {
  _FencePoint__isset() : target_system(false), target_component(false), idx(false), count(false), lat(false), lng(false) {}
  bool target_system;
  bool target_component;
  bool idx;
  bool count;
  bool lat;
  bool lng;
} _FencePoint__isset;

class FencePoint {
 public:

  static const char* ascii_fingerprint; // = "3EF1C2D1744B1D414EC6041007395D44";
  static const uint8_t binary_fingerprint[16]; // = {0x3E,0xF1,0xC2,0xD1,0x74,0x4B,0x1D,0x41,0x4E,0xC6,0x04,0x10,0x07,0x39,0x5D,0x44};

  FencePoint() : target_system(0), target_component(0), idx(0), count(0), lat(0), lng(0) {
  }

  virtual ~FencePoint() throw() {}

  int8_t target_system;
  int8_t target_component;
  int8_t idx;
  int8_t count;
  double lat;
  double lng;

  _FencePoint__isset __isset;

  void __set_target_system(const int8_t val) {
    target_system = val;
  }

  void __set_target_component(const int8_t val) {
    target_component = val;
  }

  void __set_idx(const int8_t val) {
    idx = val;
  }

  void __set_count(const int8_t val) {
    count = val;
  }

  void __set_lat(const double val) {
    lat = val;
  }

  void __set_lng(const double val) {
    lng = val;
  }

  bool operator == (const FencePoint & rhs) const
  {
    if (!(target_system == rhs.target_system))
      return false;
    if (!(target_component == rhs.target_component))
      return false;
    if (!(idx == rhs.idx))
      return false;
    if (!(count == rhs.count))
      return false;
    if (!(lat == rhs.lat))
      return false;
    if (!(lng == rhs.lng))
      return false;
    return true;
  }
  bool operator != (const FencePoint &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const FencePoint & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(FencePoint &a, FencePoint &b);

typedef struct _FenceFetchPoint__isset {
  _FenceFetchPoint__isset() : target_system(false), target_component(false), idx(false) {}
  bool target_system;
  bool target_component;
  bool idx;
} _FenceFetchPoint__isset;

class FenceFetchPoint {
 public:

  static const char* ascii_fingerprint; // = "0A77C25C826CC107FD266A55D263629B";
  static const uint8_t binary_fingerprint[16]; // = {0x0A,0x77,0xC2,0x5C,0x82,0x6C,0xC1,0x07,0xFD,0x26,0x6A,0x55,0xD2,0x63,0x62,0x9B};

  FenceFetchPoint() : target_system(0), target_component(0), idx(0) {
  }

  virtual ~FenceFetchPoint() throw() {}

  int8_t target_system;
  int8_t target_component;
  int8_t idx;

  _FenceFetchPoint__isset __isset;

  void __set_target_system(const int8_t val) {
    target_system = val;
  }

  void __set_target_component(const int8_t val) {
    target_component = val;
  }

  void __set_idx(const int8_t val) {
    idx = val;
  }

  bool operator == (const FenceFetchPoint & rhs) const
  {
    if (!(target_system == rhs.target_system))
      return false;
    if (!(target_component == rhs.target_component))
      return false;
    if (!(idx == rhs.idx))
      return false;
    return true;
  }
  bool operator != (const FenceFetchPoint &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const FenceFetchPoint & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(FenceFetchPoint &a, FenceFetchPoint &b);

typedef struct _FenceStatus__isset {
  _FenceStatus__isset() : breach_status(false), breach_count(false), breach_type(false), breach_time(false) {}
  bool breach_status;
  bool breach_count;
  bool breach_type;
  bool breach_time;
} _FenceStatus__isset;

class FenceStatus {
 public:

  static const char* ascii_fingerprint; // = "5E6FF8125CECA269AA6CCB2477354F05";
  static const uint8_t binary_fingerprint[16]; // = {0x5E,0x6F,0xF8,0x12,0x5C,0xEC,0xA2,0x69,0xAA,0x6C,0xCB,0x24,0x77,0x35,0x4F,0x05};

  FenceStatus() : breach_status(0), breach_count(0), breach_type(0), breach_time(0) {
  }

  virtual ~FenceStatus() throw() {}

  int8_t breach_status;
  int16_t breach_count;
  int8_t breach_type;
  int32_t breach_time;

  _FenceStatus__isset __isset;

  void __set_breach_status(const int8_t val) {
    breach_status = val;
  }

  void __set_breach_count(const int16_t val) {
    breach_count = val;
  }

  void __set_breach_type(const int8_t val) {
    breach_type = val;
  }

  void __set_breach_time(const int32_t val) {
    breach_time = val;
  }

  bool operator == (const FenceStatus & rhs) const
  {
    if (!(breach_status == rhs.breach_status))
      return false;
    if (!(breach_count == rhs.breach_count))
      return false;
    if (!(breach_type == rhs.breach_type))
      return false;
    if (!(breach_time == rhs.breach_time))
      return false;
    return true;
  }
  bool operator != (const FenceStatus &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const FenceStatus & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(FenceStatus &a, FenceStatus &b);

typedef struct _Ahrs__isset {
  _Ahrs__isset() : omegaIx(false), omegaIy(false), omegaIz(false), accel_weight(false), renorm_val(false), error_rp(false), error_yaw(false) {}
  bool omegaIx;
  bool omegaIy;
  bool omegaIz;
  bool accel_weight;
  bool renorm_val;
  bool error_rp;
  bool error_yaw;
} _Ahrs__isset;

class Ahrs {
 public:

  static const char* ascii_fingerprint; // = "99DE29E186210BDC0E574B6C449411C5";
  static const uint8_t binary_fingerprint[16]; // = {0x99,0xDE,0x29,0xE1,0x86,0x21,0x0B,0xDC,0x0E,0x57,0x4B,0x6C,0x44,0x94,0x11,0xC5};

  Ahrs() : omegaIx(0), omegaIy(0), omegaIz(0), accel_weight(0), renorm_val(0), error_rp(0), error_yaw(0) {
  }

  virtual ~Ahrs() throw() {}

  double omegaIx;
  double omegaIy;
  double omegaIz;
  double accel_weight;
  double renorm_val;
  double error_rp;
  double error_yaw;

  _Ahrs__isset __isset;

  void __set_omegaIx(const double val) {
    omegaIx = val;
  }

  void __set_omegaIy(const double val) {
    omegaIy = val;
  }

  void __set_omegaIz(const double val) {
    omegaIz = val;
  }

  void __set_accel_weight(const double val) {
    accel_weight = val;
  }

  void __set_renorm_val(const double val) {
    renorm_val = val;
  }

  void __set_error_rp(const double val) {
    error_rp = val;
  }

  void __set_error_yaw(const double val) {
    error_yaw = val;
  }

  bool operator == (const Ahrs & rhs) const
  {
    if (!(omegaIx == rhs.omegaIx))
      return false;
    if (!(omegaIy == rhs.omegaIy))
      return false;
    if (!(omegaIz == rhs.omegaIz))
      return false;
    if (!(accel_weight == rhs.accel_weight))
      return false;
    if (!(renorm_val == rhs.renorm_val))
      return false;
    if (!(error_rp == rhs.error_rp))
      return false;
    if (!(error_yaw == rhs.error_yaw))
      return false;
    return true;
  }
  bool operator != (const Ahrs &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Ahrs & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Ahrs &a, Ahrs &b);

typedef struct _Simstate__isset {
  _Simstate__isset() : roll(false), pitch(false), yaw(false), xacc(false), yacc(false), zacc(false), xgyro(false), ygyro(false), zgyro(false), lat(false), lng(false) {}
  bool roll;
  bool pitch;
  bool yaw;
  bool xacc;
  bool yacc;
  bool zacc;
  bool xgyro;
  bool ygyro;
  bool zgyro;
  bool lat;
  bool lng;
} _Simstate__isset;

class Simstate {
 public:

  static const char* ascii_fingerprint; // = "947C77F4BACE8131560C689714650227";
  static const uint8_t binary_fingerprint[16]; // = {0x94,0x7C,0x77,0xF4,0xBA,0xCE,0x81,0x31,0x56,0x0C,0x68,0x97,0x14,0x65,0x02,0x27};

  Simstate() : roll(0), pitch(0), yaw(0), xacc(0), yacc(0), zacc(0), xgyro(0), ygyro(0), zgyro(0), lat(0), lng(0) {
  }

  virtual ~Simstate() throw() {}

  double roll;
  double pitch;
  double yaw;
  double xacc;
  double yacc;
  double zacc;
  double xgyro;
  double ygyro;
  double zgyro;
  double lat;
  double lng;

  _Simstate__isset __isset;

  void __set_roll(const double val) {
    roll = val;
  }

  void __set_pitch(const double val) {
    pitch = val;
  }

  void __set_yaw(const double val) {
    yaw = val;
  }

  void __set_xacc(const double val) {
    xacc = val;
  }

  void __set_yacc(const double val) {
    yacc = val;
  }

  void __set_zacc(const double val) {
    zacc = val;
  }

  void __set_xgyro(const double val) {
    xgyro = val;
  }

  void __set_ygyro(const double val) {
    ygyro = val;
  }

  void __set_zgyro(const double val) {
    zgyro = val;
  }

  void __set_lat(const double val) {
    lat = val;
  }

  void __set_lng(const double val) {
    lng = val;
  }

  bool operator == (const Simstate & rhs) const
  {
    if (!(roll == rhs.roll))
      return false;
    if (!(pitch == rhs.pitch))
      return false;
    if (!(yaw == rhs.yaw))
      return false;
    if (!(xacc == rhs.xacc))
      return false;
    if (!(yacc == rhs.yacc))
      return false;
    if (!(zacc == rhs.zacc))
      return false;
    if (!(xgyro == rhs.xgyro))
      return false;
    if (!(ygyro == rhs.ygyro))
      return false;
    if (!(zgyro == rhs.zgyro))
      return false;
    if (!(lat == rhs.lat))
      return false;
    if (!(lng == rhs.lng))
      return false;
    return true;
  }
  bool operator != (const Simstate &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Simstate & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Simstate &a, Simstate &b);

typedef struct _Hwstatus__isset {
  _Hwstatus__isset() : Vcc(false), I2Cerr(false) {}
  bool Vcc;
  bool I2Cerr;
} _Hwstatus__isset;

class Hwstatus {
 public:

  static const char* ascii_fingerprint; // = "2F32B8B152B4427223DB9D670291659B";
  static const uint8_t binary_fingerprint[16]; // = {0x2F,0x32,0xB8,0xB1,0x52,0xB4,0x42,0x72,0x23,0xDB,0x9D,0x67,0x02,0x91,0x65,0x9B};

  Hwstatus() : Vcc(0), I2Cerr(0) {
  }

  virtual ~Hwstatus() throw() {}

  int16_t Vcc;
  int8_t I2Cerr;

  _Hwstatus__isset __isset;

  void __set_Vcc(const int16_t val) {
    Vcc = val;
  }

  void __set_I2Cerr(const int8_t val) {
    I2Cerr = val;
  }

  bool operator == (const Hwstatus & rhs) const
  {
    if (!(Vcc == rhs.Vcc))
      return false;
    if (!(I2Cerr == rhs.I2Cerr))
      return false;
    return true;
  }
  bool operator != (const Hwstatus &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hwstatus & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Hwstatus &a, Hwstatus &b);

typedef struct _Radio__isset {
  _Radio__isset() : rssi(false), remrssi(false), txbuf(false), noise(false), remnoise(false), rxerrors(false), fixed(false) {}
  bool rssi;
  bool remrssi;
  bool txbuf;
  bool noise;
  bool remnoise;
  bool rxerrors;
  bool fixed;
} _Radio__isset;

class Radio {
 public:

  static const char* ascii_fingerprint; // = "42B01CAA48C5DE54AA41CC15B4458FCB";
  static const uint8_t binary_fingerprint[16]; // = {0x42,0xB0,0x1C,0xAA,0x48,0xC5,0xDE,0x54,0xAA,0x41,0xCC,0x15,0xB4,0x45,0x8F,0xCB};

  Radio() : rssi(0), remrssi(0), txbuf(0), noise(0), remnoise(0), rxerrors(0), fixed(0) {
  }

  virtual ~Radio() throw() {}

  int8_t rssi;
  int8_t remrssi;
  int8_t txbuf;
  int8_t noise;
  int8_t remnoise;
  int16_t rxerrors;
  int16_t fixed;

  _Radio__isset __isset;

  void __set_rssi(const int8_t val) {
    rssi = val;
  }

  void __set_remrssi(const int8_t val) {
    remrssi = val;
  }

  void __set_txbuf(const int8_t val) {
    txbuf = val;
  }

  void __set_noise(const int8_t val) {
    noise = val;
  }

  void __set_remnoise(const int8_t val) {
    remnoise = val;
  }

  void __set_rxerrors(const int16_t val) {
    rxerrors = val;
  }

  void __set_fixed(const int16_t val) {
    fixed = val;
  }

  bool operator == (const Radio & rhs) const
  {
    if (!(rssi == rhs.rssi))
      return false;
    if (!(remrssi == rhs.remrssi))
      return false;
    if (!(txbuf == rhs.txbuf))
      return false;
    if (!(noise == rhs.noise))
      return false;
    if (!(remnoise == rhs.remnoise))
      return false;
    if (!(rxerrors == rhs.rxerrors))
      return false;
    if (!(fixed == rhs.fixed))
      return false;
    return true;
  }
  bool operator != (const Radio &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Radio & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Radio &a, Radio &b);

typedef struct _LimitsStatus__isset {
  _LimitsStatus__isset() : limits_state(false), last_trigger(false), last_action(false), last_recovery(false), last_clear(false), breach_count(false), mods_enabled(false), mods_required(false), mods_triggered(false) {}
  bool limits_state;
  bool last_trigger;
  bool last_action;
  bool last_recovery;
  bool last_clear;
  bool breach_count;
  bool mods_enabled;
  bool mods_required;
  bool mods_triggered;
} _LimitsStatus__isset;

class LimitsStatus {
 public:

  static const char* ascii_fingerprint; // = "40669755E299B2DA8CA63E09C75EF4A4";
  static const uint8_t binary_fingerprint[16]; // = {0x40,0x66,0x97,0x55,0xE2,0x99,0xB2,0xDA,0x8C,0xA6,0x3E,0x09,0xC7,0x5E,0xF4,0xA4};

  LimitsStatus() : limits_state(0), last_trigger(0), last_action(0), last_recovery(0), last_clear(0), breach_count(0), mods_enabled(0), mods_required(0), mods_triggered(0) {
  }

  virtual ~LimitsStatus() throw() {}

  int8_t limits_state;
  int32_t last_trigger;
  int32_t last_action;
  int32_t last_recovery;
  int32_t last_clear;
  int16_t breach_count;
  int8_t mods_enabled;
  int8_t mods_required;
  int8_t mods_triggered;

  _LimitsStatus__isset __isset;

  void __set_limits_state(const int8_t val) {
    limits_state = val;
  }

  void __set_last_trigger(const int32_t val) {
    last_trigger = val;
  }

  void __set_last_action(const int32_t val) {
    last_action = val;
  }

  void __set_last_recovery(const int32_t val) {
    last_recovery = val;
  }

  void __set_last_clear(const int32_t val) {
    last_clear = val;
  }

  void __set_breach_count(const int16_t val) {
    breach_count = val;
  }

  void __set_mods_enabled(const int8_t val) {
    mods_enabled = val;
  }

  void __set_mods_required(const int8_t val) {
    mods_required = val;
  }

  void __set_mods_triggered(const int8_t val) {
    mods_triggered = val;
  }

  bool operator == (const LimitsStatus & rhs) const
  {
    if (!(limits_state == rhs.limits_state))
      return false;
    if (!(last_trigger == rhs.last_trigger))
      return false;
    if (!(last_action == rhs.last_action))
      return false;
    if (!(last_recovery == rhs.last_recovery))
      return false;
    if (!(last_clear == rhs.last_clear))
      return false;
    if (!(breach_count == rhs.breach_count))
      return false;
    if (!(mods_enabled == rhs.mods_enabled))
      return false;
    if (!(mods_required == rhs.mods_required))
      return false;
    if (!(mods_triggered == rhs.mods_triggered))
      return false;
    return true;
  }
  bool operator != (const LimitsStatus &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LimitsStatus & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(LimitsStatus &a, LimitsStatus &b);

typedef struct _Wind__isset {
  _Wind__isset() : direction(false), speed(false), speed_z(false) {}
  bool direction;
  bool speed;
  bool speed_z;
} _Wind__isset;

class Wind {
 public:

  static const char* ascii_fingerprint; // = "EFFAD640FBA2CA56C50155B2A4545897";
  static const uint8_t binary_fingerprint[16]; // = {0xEF,0xFA,0xD6,0x40,0xFB,0xA2,0xCA,0x56,0xC5,0x01,0x55,0xB2,0xA4,0x54,0x58,0x97};

  Wind() : direction(0), speed(0), speed_z(0) {
  }

  virtual ~Wind() throw() {}

  double direction;
  double speed;
  double speed_z;

  _Wind__isset __isset;

  void __set_direction(const double val) {
    direction = val;
  }

  void __set_speed(const double val) {
    speed = val;
  }

  void __set_speed_z(const double val) {
    speed_z = val;
  }

  bool operator == (const Wind & rhs) const
  {
    if (!(direction == rhs.direction))
      return false;
    if (!(speed == rhs.speed))
      return false;
    if (!(speed_z == rhs.speed_z))
      return false;
    return true;
  }
  bool operator != (const Wind &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Wind & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Wind &a, Wind &b);

typedef struct _Data16__isset {
  _Data16__isset() : data16_type(false), len(false), data(false) {}
  bool data16_type;
  bool len;
  bool data;
} _Data16__isset;

class Data16 {
 public:

  static const char* ascii_fingerprint; // = "A620FE562121E92527503224024A152E";
  static const uint8_t binary_fingerprint[16]; // = {0xA6,0x20,0xFE,0x56,0x21,0x21,0xE9,0x25,0x27,0x50,0x32,0x24,0x02,0x4A,0x15,0x2E};

  Data16() : data16_type(0), len(0) {
  }

  virtual ~Data16() throw() {}

  int8_t data16_type;
  int8_t len;
  std::vector<int8_t>  data;

  _Data16__isset __isset;

  void __set_data16_type(const int8_t val) {
    data16_type = val;
  }

  void __set_len(const int8_t val) {
    len = val;
  }

  void __set_data(const std::vector<int8_t> & val) {
    data = val;
  }

  bool operator == (const Data16 & rhs) const
  {
    if (!(data16_type == rhs.data16_type))
      return false;
    if (!(len == rhs.len))
      return false;
    if (!(data == rhs.data))
      return false;
    return true;
  }
  bool operator != (const Data16 &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Data16 & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Data16 &a, Data16 &b);

typedef struct _Data32__isset {
  _Data32__isset() : data32_type(false), len(false), data(false) {}
  bool data32_type;
  bool len;
  bool data;
} _Data32__isset;

class Data32 {
 public:

  static const char* ascii_fingerprint; // = "A620FE562121E92527503224024A152E";
  static const uint8_t binary_fingerprint[16]; // = {0xA6,0x20,0xFE,0x56,0x21,0x21,0xE9,0x25,0x27,0x50,0x32,0x24,0x02,0x4A,0x15,0x2E};

  Data32() : data32_type(0), len(0) {
  }

  virtual ~Data32() throw() {}

  int8_t data32_type;
  int8_t len;
  std::vector<int8_t>  data;

  _Data32__isset __isset;

  void __set_data32_type(const int8_t val) {
    data32_type = val;
  }

  void __set_len(const int8_t val) {
    len = val;
  }

  void __set_data(const std::vector<int8_t> & val) {
    data = val;
  }

  bool operator == (const Data32 & rhs) const
  {
    if (!(data32_type == rhs.data32_type))
      return false;
    if (!(len == rhs.len))
      return false;
    if (!(data == rhs.data))
      return false;
    return true;
  }
  bool operator != (const Data32 &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Data32 & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Data32 &a, Data32 &b);

typedef struct _Data64__isset {
  _Data64__isset() : data64_type(false), len(false), data(false) {}
  bool data64_type;
  bool len;
  bool data;
} _Data64__isset;

class Data64 {
 public:

  static const char* ascii_fingerprint; // = "A620FE562121E92527503224024A152E";
  static const uint8_t binary_fingerprint[16]; // = {0xA6,0x20,0xFE,0x56,0x21,0x21,0xE9,0x25,0x27,0x50,0x32,0x24,0x02,0x4A,0x15,0x2E};

  Data64() : data64_type(0), len(0) {
  }

  virtual ~Data64() throw() {}

  int8_t data64_type;
  int8_t len;
  std::vector<int8_t>  data;

  _Data64__isset __isset;

  void __set_data64_type(const int8_t val) {
    data64_type = val;
  }

  void __set_len(const int8_t val) {
    len = val;
  }

  void __set_data(const std::vector<int8_t> & val) {
    data = val;
  }

  bool operator == (const Data64 & rhs) const
  {
    if (!(data64_type == rhs.data64_type))
      return false;
    if (!(len == rhs.len))
      return false;
    if (!(data == rhs.data))
      return false;
    return true;
  }
  bool operator != (const Data64 &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Data64 & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Data64 &a, Data64 &b);

typedef struct _Data96__isset {
  _Data96__isset() : data96_type(false), len(false), data(false) {}
  bool data96_type;
  bool len;
  bool data;
} _Data96__isset;

class Data96 {
 public:

  static const char* ascii_fingerprint; // = "A620FE562121E92527503224024A152E";
  static const uint8_t binary_fingerprint[16]; // = {0xA6,0x20,0xFE,0x56,0x21,0x21,0xE9,0x25,0x27,0x50,0x32,0x24,0x02,0x4A,0x15,0x2E};

  Data96() : data96_type(0), len(0) {
  }

  virtual ~Data96() throw() {}

  int8_t data96_type;
  int8_t len;
  std::vector<int8_t>  data;

  _Data96__isset __isset;

  void __set_data96_type(const int8_t val) {
    data96_type = val;
  }

  void __set_len(const int8_t val) {
    len = val;
  }

  void __set_data(const std::vector<int8_t> & val) {
    data = val;
  }

  bool operator == (const Data96 & rhs) const
  {
    if (!(data96_type == rhs.data96_type))
      return false;
    if (!(len == rhs.len))
      return false;
    if (!(data == rhs.data))
      return false;
    return true;
  }
  bool operator != (const Data96 &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Data96 & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Data96 &a, Data96 &b);

typedef struct _Rangefinder__isset {
  _Rangefinder__isset() : distance(false), voltage(false) {}
  bool distance;
  bool voltage;
} _Rangefinder__isset;

class Rangefinder {
 public:

  static const char* ascii_fingerprint; // = "EA2086D2BB14222991D7B0497DE7B58B";
  static const uint8_t binary_fingerprint[16]; // = {0xEA,0x20,0x86,0xD2,0xBB,0x14,0x22,0x29,0x91,0xD7,0xB0,0x49,0x7D,0xE7,0xB5,0x8B};

  Rangefinder() : distance(0), voltage(0) {
  }

  virtual ~Rangefinder() throw() {}

  double distance;
  double voltage;

  _Rangefinder__isset __isset;

  void __set_distance(const double val) {
    distance = val;
  }

  void __set_voltage(const double val) {
    voltage = val;
  }

  bool operator == (const Rangefinder & rhs) const
  {
    if (!(distance == rhs.distance))
      return false;
    if (!(voltage == rhs.voltage))
      return false;
    return true;
  }
  bool operator != (const Rangefinder &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Rangefinder & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Rangefinder &a, Rangefinder &b);

}} // namespace

#endif
