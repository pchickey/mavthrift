/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "ardupilotmega_types.h"

#include <algorithm>

namespace mavlink { namespace thrift {

int _kArdupilotmegaMessageTypesValues[] = {
  ArdupilotmegaMessageTypes::HEARTBEAT,
  ArdupilotmegaMessageTypes::SYS_STATUS,
  ArdupilotmegaMessageTypes::SYSTEM_TIME,
  ArdupilotmegaMessageTypes::PING,
  ArdupilotmegaMessageTypes::CHANGE_OPERATOR_CONTROL,
  ArdupilotmegaMessageTypes::CHANGE_OPERATOR_CONTROL_ACK,
  ArdupilotmegaMessageTypes::AUTH_KEY,
  ArdupilotmegaMessageTypes::SET_MODE,
  ArdupilotmegaMessageTypes::PARAM_REQUEST_READ,
  ArdupilotmegaMessageTypes::PARAM_REQUEST_LIST,
  ArdupilotmegaMessageTypes::PARAM_VALUE,
  ArdupilotmegaMessageTypes::PARAM_SET,
  ArdupilotmegaMessageTypes::GPS_RAW_INT,
  ArdupilotmegaMessageTypes::GPS_STATUS,
  ArdupilotmegaMessageTypes::SCALED_IMU,
  ArdupilotmegaMessageTypes::RAW_IMU,
  ArdupilotmegaMessageTypes::RAW_PRESSURE,
  ArdupilotmegaMessageTypes::SCALED_PRESSURE,
  ArdupilotmegaMessageTypes::ATTITUDE,
  ArdupilotmegaMessageTypes::ATTITUDE_QUATERNION,
  ArdupilotmegaMessageTypes::LOCAL_POSITION_NED,
  ArdupilotmegaMessageTypes::GLOBAL_POSITION_INT,
  ArdupilotmegaMessageTypes::RC_CHANNELS_SCALED,
  ArdupilotmegaMessageTypes::RC_CHANNELS_RAW,
  ArdupilotmegaMessageTypes::SERVO_OUTPUT_RAW,
  ArdupilotmegaMessageTypes::MISSION_REQUEST_PARTIAL_LIST,
  ArdupilotmegaMessageTypes::MISSION_WRITE_PARTIAL_LIST,
  ArdupilotmegaMessageTypes::MISSION_ITEM,
  ArdupilotmegaMessageTypes::MISSION_REQUEST,
  ArdupilotmegaMessageTypes::MISSION_SET_CURRENT,
  ArdupilotmegaMessageTypes::MISSION_CURRENT,
  ArdupilotmegaMessageTypes::MISSION_REQUEST_LIST,
  ArdupilotmegaMessageTypes::MISSION_COUNT,
  ArdupilotmegaMessageTypes::MISSION_CLEAR_ALL,
  ArdupilotmegaMessageTypes::MISSION_ITEM_REACHED,
  ArdupilotmegaMessageTypes::MISSION_ACK,
  ArdupilotmegaMessageTypes::SET_GPS_GLOBAL_ORIGIN,
  ArdupilotmegaMessageTypes::GPS_GLOBAL_ORIGIN,
  ArdupilotmegaMessageTypes::SET_LOCAL_POSITION_SETPOINT,
  ArdupilotmegaMessageTypes::LOCAL_POSITION_SETPOINT,
  ArdupilotmegaMessageTypes::GLOBAL_POSITION_SETPOINT_INT,
  ArdupilotmegaMessageTypes::SET_GLOBAL_POSITION_SETPOINT_INT,
  ArdupilotmegaMessageTypes::SAFETY_SET_ALLOWED_AREA,
  ArdupilotmegaMessageTypes::SAFETY_ALLOWED_AREA,
  ArdupilotmegaMessageTypes::SET_ROLL_PITCH_YAW_THRUST,
  ArdupilotmegaMessageTypes::SET_ROLL_PITCH_YAW_SPEED_THRUST,
  ArdupilotmegaMessageTypes::ROLL_PITCH_YAW_THRUST_SETPOINT,
  ArdupilotmegaMessageTypes::ROLL_PITCH_YAW_SPEED_THRUST_SETPOINT,
  ArdupilotmegaMessageTypes::SET_QUAD_MOTORS_SETPOINT,
  ArdupilotmegaMessageTypes::SET_QUAD_SWARM_ROLL_PITCH_YAW_THRUST,
  ArdupilotmegaMessageTypes::NAV_CONTROLLER_OUTPUT,
  ArdupilotmegaMessageTypes::SET_QUAD_SWARM_LED_ROLL_PITCH_YAW_THRUST,
  ArdupilotmegaMessageTypes::STATE_CORRECTION,
  ArdupilotmegaMessageTypes::REQUEST_DATA_STREAM,
  ArdupilotmegaMessageTypes::DATA_STREAM,
  ArdupilotmegaMessageTypes::MANUAL_CONTROL,
  ArdupilotmegaMessageTypes::RC_CHANNELS_OVERRIDE,
  ArdupilotmegaMessageTypes::VFR_HUD,
  ArdupilotmegaMessageTypes::COMMAND_LONG,
  ArdupilotmegaMessageTypes::COMMAND_ACK,
  ArdupilotmegaMessageTypes::ROLL_PITCH_YAW_RATES_THRUST_SETPOINT,
  ArdupilotmegaMessageTypes::MANUAL_SETPOINT,
  ArdupilotmegaMessageTypes::LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET,
  ArdupilotmegaMessageTypes::HIL_STATE,
  ArdupilotmegaMessageTypes::HIL_CONTROLS,
  ArdupilotmegaMessageTypes::HIL_RC_INPUTS_RAW,
  ArdupilotmegaMessageTypes::OPTICAL_FLOW,
  ArdupilotmegaMessageTypes::GLOBAL_VISION_POSITION_ESTIMATE,
  ArdupilotmegaMessageTypes::VISION_POSITION_ESTIMATE,
  ArdupilotmegaMessageTypes::VISION_SPEED_ESTIMATE,
  ArdupilotmegaMessageTypes::VICON_POSITION_ESTIMATE,
  ArdupilotmegaMessageTypes::HIGHRES_IMU,
  ArdupilotmegaMessageTypes::OMNIDIRECTIONAL_FLOW,
  ArdupilotmegaMessageTypes::FILE_TRANSFER_START,
  ArdupilotmegaMessageTypes::FILE_TRANSFER_DIR_LIST,
  ArdupilotmegaMessageTypes::FILE_TRANSFER_RES,
  ArdupilotmegaMessageTypes::BATTERY_STATUS,
  ArdupilotmegaMessageTypes::SETPOINT_8DOF,
  ArdupilotmegaMessageTypes::SETPOINT_6DOF,
  ArdupilotmegaMessageTypes::MEMORY_VECT,
  ArdupilotmegaMessageTypes::DEBUG_VECT,
  ArdupilotmegaMessageTypes::NAMED_VALUE_FLOAT,
  ArdupilotmegaMessageTypes::NAMED_VALUE_INT,
  ArdupilotmegaMessageTypes::STATUSTEXT,
  ArdupilotmegaMessageTypes::DEBUG,
  ArdupilotmegaMessageTypes::SENSOR_OFFSETS,
  ArdupilotmegaMessageTypes::SET_MAG_OFFSETS,
  ArdupilotmegaMessageTypes::MEMINFO,
  ArdupilotmegaMessageTypes::AP_ADC,
  ArdupilotmegaMessageTypes::DIGICAM_CONFIGURE,
  ArdupilotmegaMessageTypes::DIGICAM_CONTROL,
  ArdupilotmegaMessageTypes::MOUNT_CONFIGURE,
  ArdupilotmegaMessageTypes::MOUNT_CONTROL,
  ArdupilotmegaMessageTypes::MOUNT_STATUS,
  ArdupilotmegaMessageTypes::FENCE_POINT,
  ArdupilotmegaMessageTypes::FENCE_FETCH_POINT,
  ArdupilotmegaMessageTypes::FENCE_STATUS,
  ArdupilotmegaMessageTypes::AHRS,
  ArdupilotmegaMessageTypes::SIMSTATE,
  ArdupilotmegaMessageTypes::HWSTATUS,
  ArdupilotmegaMessageTypes::RADIO,
  ArdupilotmegaMessageTypes::LIMITS_STATUS,
  ArdupilotmegaMessageTypes::WIND,
  ArdupilotmegaMessageTypes::DATA16,
  ArdupilotmegaMessageTypes::DATA32,
  ArdupilotmegaMessageTypes::DATA64,
  ArdupilotmegaMessageTypes::DATA96,
  ArdupilotmegaMessageTypes::RANGEFINDER
};
const char* _kArdupilotmegaMessageTypesNames[] = {
  "HEARTBEAT",
  "SYS_STATUS",
  "SYSTEM_TIME",
  "PING",
  "CHANGE_OPERATOR_CONTROL",
  "CHANGE_OPERATOR_CONTROL_ACK",
  "AUTH_KEY",
  "SET_MODE",
  "PARAM_REQUEST_READ",
  "PARAM_REQUEST_LIST",
  "PARAM_VALUE",
  "PARAM_SET",
  "GPS_RAW_INT",
  "GPS_STATUS",
  "SCALED_IMU",
  "RAW_IMU",
  "RAW_PRESSURE",
  "SCALED_PRESSURE",
  "ATTITUDE",
  "ATTITUDE_QUATERNION",
  "LOCAL_POSITION_NED",
  "GLOBAL_POSITION_INT",
  "RC_CHANNELS_SCALED",
  "RC_CHANNELS_RAW",
  "SERVO_OUTPUT_RAW",
  "MISSION_REQUEST_PARTIAL_LIST",
  "MISSION_WRITE_PARTIAL_LIST",
  "MISSION_ITEM",
  "MISSION_REQUEST",
  "MISSION_SET_CURRENT",
  "MISSION_CURRENT",
  "MISSION_REQUEST_LIST",
  "MISSION_COUNT",
  "MISSION_CLEAR_ALL",
  "MISSION_ITEM_REACHED",
  "MISSION_ACK",
  "SET_GPS_GLOBAL_ORIGIN",
  "GPS_GLOBAL_ORIGIN",
  "SET_LOCAL_POSITION_SETPOINT",
  "LOCAL_POSITION_SETPOINT",
  "GLOBAL_POSITION_SETPOINT_INT",
  "SET_GLOBAL_POSITION_SETPOINT_INT",
  "SAFETY_SET_ALLOWED_AREA",
  "SAFETY_ALLOWED_AREA",
  "SET_ROLL_PITCH_YAW_THRUST",
  "SET_ROLL_PITCH_YAW_SPEED_THRUST",
  "ROLL_PITCH_YAW_THRUST_SETPOINT",
  "ROLL_PITCH_YAW_SPEED_THRUST_SETPOINT",
  "SET_QUAD_MOTORS_SETPOINT",
  "SET_QUAD_SWARM_ROLL_PITCH_YAW_THRUST",
  "NAV_CONTROLLER_OUTPUT",
  "SET_QUAD_SWARM_LED_ROLL_PITCH_YAW_THRUST",
  "STATE_CORRECTION",
  "REQUEST_DATA_STREAM",
  "DATA_STREAM",
  "MANUAL_CONTROL",
  "RC_CHANNELS_OVERRIDE",
  "VFR_HUD",
  "COMMAND_LONG",
  "COMMAND_ACK",
  "ROLL_PITCH_YAW_RATES_THRUST_SETPOINT",
  "MANUAL_SETPOINT",
  "LOCAL_POSITION_NED_SYSTEM_GLOBAL_OFFSET",
  "HIL_STATE",
  "HIL_CONTROLS",
  "HIL_RC_INPUTS_RAW",
  "OPTICAL_FLOW",
  "GLOBAL_VISION_POSITION_ESTIMATE",
  "VISION_POSITION_ESTIMATE",
  "VISION_SPEED_ESTIMATE",
  "VICON_POSITION_ESTIMATE",
  "HIGHRES_IMU",
  "OMNIDIRECTIONAL_FLOW",
  "FILE_TRANSFER_START",
  "FILE_TRANSFER_DIR_LIST",
  "FILE_TRANSFER_RES",
  "BATTERY_STATUS",
  "SETPOINT_8DOF",
  "SETPOINT_6DOF",
  "MEMORY_VECT",
  "DEBUG_VECT",
  "NAMED_VALUE_FLOAT",
  "NAMED_VALUE_INT",
  "STATUSTEXT",
  "DEBUG",
  "SENSOR_OFFSETS",
  "SET_MAG_OFFSETS",
  "MEMINFO",
  "AP_ADC",
  "DIGICAM_CONFIGURE",
  "DIGICAM_CONTROL",
  "MOUNT_CONFIGURE",
  "MOUNT_CONTROL",
  "MOUNT_STATUS",
  "FENCE_POINT",
  "FENCE_FETCH_POINT",
  "FENCE_STATUS",
  "AHRS",
  "SIMSTATE",
  "HWSTATUS",
  "RADIO",
  "LIMITS_STATUS",
  "WIND",
  "DATA16",
  "DATA32",
  "DATA64",
  "DATA96",
  "RANGEFINDER"
};
const std::map<int, const char*> _ArdupilotmegaMessageTypes_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(108, _kArdupilotmegaMessageTypesValues, _kArdupilotmegaMessageTypesNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kMount_modeValues[] = {
  Mount_mode::RETRACT,
  Mount_mode::NEUTRAL,
  Mount_mode::MAVLINK_TARGETING,
  Mount_mode::RC_TARGETING,
  Mount_mode::GPS_POINT
};
const char* _kMount_modeNames[] = {
  "RETRACT",
  "NEUTRAL",
  "MAVLINK_TARGETING",
  "RC_TARGETING",
  "GPS_POINT"
};
const std::map<int, const char*> _Mount_mode_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kMount_modeValues, _kMount_modeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kCmdValues[] = {
  Cmd::NAV_WAYPOINT,
  Cmd::NAV_LOITER_UNLIM,
  Cmd::NAV_LOITER_TURNS,
  Cmd::NAV_LOITER_TIME,
  Cmd::NAV_RETURN_TO_LAUNCH,
  Cmd::NAV_LAND,
  Cmd::NAV_TAKEOFF,
  Cmd::NAV_ROI,
  Cmd::NAV_PATHPLANNING,
  Cmd::NAV_LAST,
  Cmd::CONDITION_DELAY,
  Cmd::CONDITION_CHANGE_ALT,
  Cmd::CONDITION_DISTANCE,
  Cmd::CONDITION_YAW,
  Cmd::CONDITION_LAST,
  Cmd::DO_SET_MODE,
  Cmd::DO_JUMP,
  Cmd::DO_CHANGE_SPEED,
  Cmd::DO_SET_HOME,
  Cmd::DO_SET_PARAMETER,
  Cmd::DO_SET_RELAY,
  Cmd::DO_REPEAT_RELAY,
  Cmd::DO_SET_SERVO,
  Cmd::DO_REPEAT_SERVO,
  Cmd::DO_CONTROL_VIDEO,
  Cmd::DO_DIGICAM_CONFIGURE,
  Cmd::DO_DIGICAM_CONTROL,
  Cmd::DO_MOUNT_CONFIGURE,
  Cmd::DO_MOUNT_CONTROL,
  Cmd::DO_LAST,
  Cmd::PREFLIGHT_CALIBRATION,
  Cmd::PREFLIGHT_SET_SENSOR_OFFSETS,
  Cmd::PREFLIGHT_STORAGE,
  Cmd::PREFLIGHT_REBOOT_SHUTDOWN,
  Cmd::OVERRIDE_GOTO,
  Cmd::MISSION_START,
  Cmd::COMPONENT_ARM_DISARM
};
const char* _kCmdNames[] = {
  "NAV_WAYPOINT",
  "NAV_LOITER_UNLIM",
  "NAV_LOITER_TURNS",
  "NAV_LOITER_TIME",
  "NAV_RETURN_TO_LAUNCH",
  "NAV_LAND",
  "NAV_TAKEOFF",
  "NAV_ROI",
  "NAV_PATHPLANNING",
  "NAV_LAST",
  "CONDITION_DELAY",
  "CONDITION_CHANGE_ALT",
  "CONDITION_DISTANCE",
  "CONDITION_YAW",
  "CONDITION_LAST",
  "DO_SET_MODE",
  "DO_JUMP",
  "DO_CHANGE_SPEED",
  "DO_SET_HOME",
  "DO_SET_PARAMETER",
  "DO_SET_RELAY",
  "DO_REPEAT_RELAY",
  "DO_SET_SERVO",
  "DO_REPEAT_SERVO",
  "DO_CONTROL_VIDEO",
  "DO_DIGICAM_CONFIGURE",
  "DO_DIGICAM_CONTROL",
  "DO_MOUNT_CONFIGURE",
  "DO_MOUNT_CONTROL",
  "DO_LAST",
  "PREFLIGHT_CALIBRATION",
  "PREFLIGHT_SET_SENSOR_OFFSETS",
  "PREFLIGHT_STORAGE",
  "PREFLIGHT_REBOOT_SHUTDOWN",
  "OVERRIDE_GOTO",
  "MISSION_START",
  "COMPONENT_ARM_DISARM"
};
const std::map<int, const char*> _Cmd_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(37, _kCmdValues, _kCmdNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kFence_actionValues[] = {
  Fence_action::NONE,
  Fence_action::GUIDED,
  Fence_action::REPORT
};
const char* _kFence_actionNames[] = {
  "NONE",
  "GUIDED",
  "REPORT"
};
const std::map<int, const char*> _Fence_action_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kFence_actionValues, _kFence_actionNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kFence_breachValues[] = {
  Fence_breach::NONE,
  Fence_breach::MINALT,
  Fence_breach::MAXALT,
  Fence_breach::BOUNDARY
};
const char* _kFence_breachNames[] = {
  "NONE",
  "MINALT",
  "MAXALT",
  "BOUNDARY"
};
const std::map<int, const char*> _Fence_breach_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kFence_breachValues, _kFence_breachNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kLimits_stateValues[] = {
  Limits_state::INIT,
  Limits_state::DISABLED,
  Limits_state::ENABLED,
  Limits_state::TRIGGERED,
  Limits_state::RECOVERING,
  Limits_state::RECOVERED,
  Limits_state::STATE_ENUM_END
};
const char* _kLimits_stateNames[] = {
  "INIT",
  "DISABLED",
  "ENABLED",
  "TRIGGERED",
  "RECOVERING",
  "RECOVERED",
  "STATE_ENUM_END"
};
const std::map<int, const char*> _Limits_state_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(7, _kLimits_stateValues, _kLimits_stateNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kLimit_moduleValues[] = {
  Limit_module::GPSLOCK,
  Limit_module::GEOFENCE,
  Limit_module::ALTITUDE,
  Limit_module::MODULE_ENUM_END
};
const char* _kLimit_moduleNames[] = {
  "GPSLOCK",
  "GEOFENCE",
  "ALTITUDE",
  "MODULE_ENUM_END"
};
const std::map<int, const char*> _Limit_module_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kLimit_moduleValues, _kLimit_moduleNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

const char* SensorOffsets::ascii_fingerprint = "5C8FF195E58A59EDF3556BECA79CE081";
const uint8_t SensorOffsets::binary_fingerprint[16] = {0x5C,0x8F,0xF1,0x95,0xE5,0x8A,0x59,0xED,0xF3,0x55,0x6B,0xEC,0xA7,0x9C,0xE0,0x81};

uint32_t SensorOffsets::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->mag_ofs_x);
          this->__isset.mag_ofs_x = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->mag_ofs_y);
          this->__isset.mag_ofs_y = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->mag_ofs_z);
          this->__isset.mag_ofs_z = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->mag_declination);
          this->__isset.mag_declination = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->raw_press);
          this->__isset.raw_press = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->raw_temp);
          this->__isset.raw_temp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->gyro_cal_x);
          this->__isset.gyro_cal_x = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->gyro_cal_y);
          this->__isset.gyro_cal_y = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->gyro_cal_z);
          this->__isset.gyro_cal_z = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->accel_cal_x);
          this->__isset.accel_cal_x = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->accel_cal_y);
          this->__isset.accel_cal_y = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->accel_cal_z);
          this->__isset.accel_cal_z = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SensorOffsets::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SensorOffsets");

  xfer += oprot->writeFieldBegin("mag_ofs_x", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->mag_ofs_x);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mag_ofs_y", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16(this->mag_ofs_y);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mag_ofs_z", ::apache::thrift::protocol::T_I16, 3);
  xfer += oprot->writeI16(this->mag_ofs_z);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mag_declination", ::apache::thrift::protocol::T_DOUBLE, 4);
  xfer += oprot->writeDouble(this->mag_declination);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("raw_press", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->raw_press);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("raw_temp", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->raw_temp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("gyro_cal_x", ::apache::thrift::protocol::T_DOUBLE, 7);
  xfer += oprot->writeDouble(this->gyro_cal_x);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("gyro_cal_y", ::apache::thrift::protocol::T_DOUBLE, 8);
  xfer += oprot->writeDouble(this->gyro_cal_y);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("gyro_cal_z", ::apache::thrift::protocol::T_DOUBLE, 9);
  xfer += oprot->writeDouble(this->gyro_cal_z);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("accel_cal_x", ::apache::thrift::protocol::T_DOUBLE, 10);
  xfer += oprot->writeDouble(this->accel_cal_x);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("accel_cal_y", ::apache::thrift::protocol::T_DOUBLE, 11);
  xfer += oprot->writeDouble(this->accel_cal_y);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("accel_cal_z", ::apache::thrift::protocol::T_DOUBLE, 12);
  xfer += oprot->writeDouble(this->accel_cal_z);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SensorOffsets &a, SensorOffsets &b) {
  using ::std::swap;
  swap(a.mag_ofs_x, b.mag_ofs_x);
  swap(a.mag_ofs_y, b.mag_ofs_y);
  swap(a.mag_ofs_z, b.mag_ofs_z);
  swap(a.mag_declination, b.mag_declination);
  swap(a.raw_press, b.raw_press);
  swap(a.raw_temp, b.raw_temp);
  swap(a.gyro_cal_x, b.gyro_cal_x);
  swap(a.gyro_cal_y, b.gyro_cal_y);
  swap(a.gyro_cal_z, b.gyro_cal_z);
  swap(a.accel_cal_x, b.accel_cal_x);
  swap(a.accel_cal_y, b.accel_cal_y);
  swap(a.accel_cal_z, b.accel_cal_z);
  swap(a.__isset, b.__isset);
}

const char* SetMagOffsets::ascii_fingerprint = "99A3CB793D08BB7B4ACF4E3955FADD82";
const uint8_t SetMagOffsets::binary_fingerprint[16] = {0x99,0xA3,0xCB,0x79,0x3D,0x08,0xBB,0x7B,0x4A,0xCF,0x4E,0x39,0x55,0xFA,0xDD,0x82};

uint32_t SetMagOffsets::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->target_system);
          this->__isset.target_system = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->target_component);
          this->__isset.target_component = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->mag_ofs_x);
          this->__isset.mag_ofs_x = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->mag_ofs_y);
          this->__isset.mag_ofs_y = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->mag_ofs_z);
          this->__isset.mag_ofs_z = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SetMagOffsets::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("SetMagOffsets");

  xfer += oprot->writeFieldBegin("target_system", ::apache::thrift::protocol::T_BYTE, 1);
  xfer += oprot->writeByte(this->target_system);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("target_component", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte(this->target_component);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mag_ofs_x", ::apache::thrift::protocol::T_I16, 3);
  xfer += oprot->writeI16(this->mag_ofs_x);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mag_ofs_y", ::apache::thrift::protocol::T_I16, 4);
  xfer += oprot->writeI16(this->mag_ofs_y);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mag_ofs_z", ::apache::thrift::protocol::T_I16, 5);
  xfer += oprot->writeI16(this->mag_ofs_z);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SetMagOffsets &a, SetMagOffsets &b) {
  using ::std::swap;
  swap(a.target_system, b.target_system);
  swap(a.target_component, b.target_component);
  swap(a.mag_ofs_x, b.mag_ofs_x);
  swap(a.mag_ofs_y, b.mag_ofs_y);
  swap(a.mag_ofs_z, b.mag_ofs_z);
  swap(a.__isset, b.__isset);
}

const char* Meminfo::ascii_fingerprint = "C88FB7958D86460D03E699333A272947";
const uint8_t Meminfo::binary_fingerprint[16] = {0xC8,0x8F,0xB7,0x95,0x8D,0x86,0x46,0x0D,0x03,0xE6,0x99,0x33,0x3A,0x27,0x29,0x47};

uint32_t Meminfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->brkval);
          this->__isset.brkval = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->freemem);
          this->__isset.freemem = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Meminfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Meminfo");

  xfer += oprot->writeFieldBegin("brkval", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->brkval);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("freemem", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16(this->freemem);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Meminfo &a, Meminfo &b) {
  using ::std::swap;
  swap(a.brkval, b.brkval);
  swap(a.freemem, b.freemem);
  swap(a.__isset, b.__isset);
}

const char* ApAdc::ascii_fingerprint = "4BFEB2A4F7E3C310FEEE505404210134";
const uint8_t ApAdc::binary_fingerprint[16] = {0x4B,0xFE,0xB2,0xA4,0xF7,0xE3,0xC3,0x10,0xFE,0xEE,0x50,0x54,0x04,0x21,0x01,0x34};

uint32_t ApAdc::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->adc1);
          this->__isset.adc1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->adc2);
          this->__isset.adc2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->adc3);
          this->__isset.adc3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->adc4);
          this->__isset.adc4 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->adc5);
          this->__isset.adc5 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->adc6);
          this->__isset.adc6 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ApAdc::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("ApAdc");

  xfer += oprot->writeFieldBegin("adc1", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->adc1);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("adc2", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16(this->adc2);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("adc3", ::apache::thrift::protocol::T_I16, 3);
  xfer += oprot->writeI16(this->adc3);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("adc4", ::apache::thrift::protocol::T_I16, 4);
  xfer += oprot->writeI16(this->adc4);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("adc5", ::apache::thrift::protocol::T_I16, 5);
  xfer += oprot->writeI16(this->adc5);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("adc6", ::apache::thrift::protocol::T_I16, 6);
  xfer += oprot->writeI16(this->adc6);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ApAdc &a, ApAdc &b) {
  using ::std::swap;
  swap(a.adc1, b.adc1);
  swap(a.adc2, b.adc2);
  swap(a.adc3, b.adc3);
  swap(a.adc4, b.adc4);
  swap(a.adc5, b.adc5);
  swap(a.adc6, b.adc6);
  swap(a.__isset, b.__isset);
}

const char* DigicamConfigure::ascii_fingerprint = "083C6024F6C6CCB2309FE66335D221CB";
const uint8_t DigicamConfigure::binary_fingerprint[16] = {0x08,0x3C,0x60,0x24,0xF6,0xC6,0xCC,0xB2,0x30,0x9F,0xE6,0x63,0x35,0xD2,0x21,0xCB};

uint32_t DigicamConfigure::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->target_system);
          this->__isset.target_system = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->target_component);
          this->__isset.target_component = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->mode);
          this->__isset.mode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->shutter_speed);
          this->__isset.shutter_speed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->aperture);
          this->__isset.aperture = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->iso);
          this->__isset.iso = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->exposure_type);
          this->__isset.exposure_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->command_id);
          this->__isset.command_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->engine_cut_off);
          this->__isset.engine_cut_off = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->extra_param);
          this->__isset.extra_param = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->extra_value);
          this->__isset.extra_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DigicamConfigure::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("DigicamConfigure");

  xfer += oprot->writeFieldBegin("target_system", ::apache::thrift::protocol::T_BYTE, 1);
  xfer += oprot->writeByte(this->target_system);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("target_component", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte(this->target_component);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mode", ::apache::thrift::protocol::T_BYTE, 3);
  xfer += oprot->writeByte(this->mode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("shutter_speed", ::apache::thrift::protocol::T_I16, 4);
  xfer += oprot->writeI16(this->shutter_speed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("aperture", ::apache::thrift::protocol::T_BYTE, 5);
  xfer += oprot->writeByte(this->aperture);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iso", ::apache::thrift::protocol::T_BYTE, 6);
  xfer += oprot->writeByte(this->iso);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("exposure_type", ::apache::thrift::protocol::T_BYTE, 7);
  xfer += oprot->writeByte(this->exposure_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("command_id", ::apache::thrift::protocol::T_BYTE, 8);
  xfer += oprot->writeByte(this->command_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("engine_cut_off", ::apache::thrift::protocol::T_BYTE, 9);
  xfer += oprot->writeByte(this->engine_cut_off);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("extra_param", ::apache::thrift::protocol::T_BYTE, 10);
  xfer += oprot->writeByte(this->extra_param);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("extra_value", ::apache::thrift::protocol::T_DOUBLE, 11);
  xfer += oprot->writeDouble(this->extra_value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DigicamConfigure &a, DigicamConfigure &b) {
  using ::std::swap;
  swap(a.target_system, b.target_system);
  swap(a.target_component, b.target_component);
  swap(a.mode, b.mode);
  swap(a.shutter_speed, b.shutter_speed);
  swap(a.aperture, b.aperture);
  swap(a.iso, b.iso);
  swap(a.exposure_type, b.exposure_type);
  swap(a.command_id, b.command_id);
  swap(a.engine_cut_off, b.engine_cut_off);
  swap(a.extra_param, b.extra_param);
  swap(a.extra_value, b.extra_value);
  swap(a.__isset, b.__isset);
}

const char* DigicamControl::ascii_fingerprint = "379FC86FB4BB211EF292113F1DBBEB9D";
const uint8_t DigicamControl::binary_fingerprint[16] = {0x37,0x9F,0xC8,0x6F,0xB4,0xBB,0x21,0x1E,0xF2,0x92,0x11,0x3F,0x1D,0xBB,0xEB,0x9D};

uint32_t DigicamControl::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->target_system);
          this->__isset.target_system = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->target_component);
          this->__isset.target_component = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->session);
          this->__isset.session = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->zoom_pos);
          this->__isset.zoom_pos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->zoom_step);
          this->__isset.zoom_step = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->focus_lock);
          this->__isset.focus_lock = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->shot);
          this->__isset.shot = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->command_id);
          this->__isset.command_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->extra_param);
          this->__isset.extra_param = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->extra_value);
          this->__isset.extra_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DigicamControl::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("DigicamControl");

  xfer += oprot->writeFieldBegin("target_system", ::apache::thrift::protocol::T_BYTE, 1);
  xfer += oprot->writeByte(this->target_system);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("target_component", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte(this->target_component);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("session", ::apache::thrift::protocol::T_BYTE, 3);
  xfer += oprot->writeByte(this->session);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("zoom_pos", ::apache::thrift::protocol::T_BYTE, 4);
  xfer += oprot->writeByte(this->zoom_pos);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("zoom_step", ::apache::thrift::protocol::T_BYTE, 5);
  xfer += oprot->writeByte(this->zoom_step);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("focus_lock", ::apache::thrift::protocol::T_BYTE, 6);
  xfer += oprot->writeByte(this->focus_lock);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("shot", ::apache::thrift::protocol::T_BYTE, 7);
  xfer += oprot->writeByte(this->shot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("command_id", ::apache::thrift::protocol::T_BYTE, 8);
  xfer += oprot->writeByte(this->command_id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("extra_param", ::apache::thrift::protocol::T_BYTE, 9);
  xfer += oprot->writeByte(this->extra_param);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("extra_value", ::apache::thrift::protocol::T_DOUBLE, 10);
  xfer += oprot->writeDouble(this->extra_value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DigicamControl &a, DigicamControl &b) {
  using ::std::swap;
  swap(a.target_system, b.target_system);
  swap(a.target_component, b.target_component);
  swap(a.session, b.session);
  swap(a.zoom_pos, b.zoom_pos);
  swap(a.zoom_step, b.zoom_step);
  swap(a.focus_lock, b.focus_lock);
  swap(a.shot, b.shot);
  swap(a.command_id, b.command_id);
  swap(a.extra_param, b.extra_param);
  swap(a.extra_value, b.extra_value);
  swap(a.__isset, b.__isset);
}

const char* MountConfigure::ascii_fingerprint = "0F8D4306D81F0F21E94B977AA746DB78";
const uint8_t MountConfigure::binary_fingerprint[16] = {0x0F,0x8D,0x43,0x06,0xD8,0x1F,0x0F,0x21,0xE9,0x4B,0x97,0x7A,0xA7,0x46,0xDB,0x78};

uint32_t MountConfigure::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->target_system);
          this->__isset.target_system = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->target_component);
          this->__isset.target_component = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->mount_mode);
          this->__isset.mount_mode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->stab_roll);
          this->__isset.stab_roll = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->stab_pitch);
          this->__isset.stab_pitch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->stab_yaw);
          this->__isset.stab_yaw = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MountConfigure::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("MountConfigure");

  xfer += oprot->writeFieldBegin("target_system", ::apache::thrift::protocol::T_BYTE, 1);
  xfer += oprot->writeByte(this->target_system);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("target_component", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte(this->target_component);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mount_mode", ::apache::thrift::protocol::T_BYTE, 3);
  xfer += oprot->writeByte(this->mount_mode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stab_roll", ::apache::thrift::protocol::T_BYTE, 4);
  xfer += oprot->writeByte(this->stab_roll);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stab_pitch", ::apache::thrift::protocol::T_BYTE, 5);
  xfer += oprot->writeByte(this->stab_pitch);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stab_yaw", ::apache::thrift::protocol::T_BYTE, 6);
  xfer += oprot->writeByte(this->stab_yaw);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MountConfigure &a, MountConfigure &b) {
  using ::std::swap;
  swap(a.target_system, b.target_system);
  swap(a.target_component, b.target_component);
  swap(a.mount_mode, b.mount_mode);
  swap(a.stab_roll, b.stab_roll);
  swap(a.stab_pitch, b.stab_pitch);
  swap(a.stab_yaw, b.stab_yaw);
  swap(a.__isset, b.__isset);
}

const char* MountControl::ascii_fingerprint = "F2D4822E3C18F828EEAC2C38275443E1";
const uint8_t MountControl::binary_fingerprint[16] = {0xF2,0xD4,0x82,0x2E,0x3C,0x18,0xF8,0x28,0xEE,0xAC,0x2C,0x38,0x27,0x54,0x43,0xE1};

uint32_t MountControl::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->target_system);
          this->__isset.target_system = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->target_component);
          this->__isset.target_component = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->input_a);
          this->__isset.input_a = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->input_b);
          this->__isset.input_b = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->input_c);
          this->__isset.input_c = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->save_position);
          this->__isset.save_position = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MountControl::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("MountControl");

  xfer += oprot->writeFieldBegin("target_system", ::apache::thrift::protocol::T_BYTE, 1);
  xfer += oprot->writeByte(this->target_system);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("target_component", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte(this->target_component);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("input_a", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->input_a);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("input_b", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->input_b);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("input_c", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->input_c);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("save_position", ::apache::thrift::protocol::T_BYTE, 6);
  xfer += oprot->writeByte(this->save_position);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MountControl &a, MountControl &b) {
  using ::std::swap;
  swap(a.target_system, b.target_system);
  swap(a.target_component, b.target_component);
  swap(a.input_a, b.input_a);
  swap(a.input_b, b.input_b);
  swap(a.input_c, b.input_c);
  swap(a.save_position, b.save_position);
  swap(a.__isset, b.__isset);
}

const char* MountStatus::ascii_fingerprint = "1919976FBA738E4D68959537BAB9AED6";
const uint8_t MountStatus::binary_fingerprint[16] = {0x19,0x19,0x97,0x6F,0xBA,0x73,0x8E,0x4D,0x68,0x95,0x95,0x37,0xBA,0xB9,0xAE,0xD6};

uint32_t MountStatus::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->target_system);
          this->__isset.target_system = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->target_component);
          this->__isset.target_component = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->pointing_a);
          this->__isset.pointing_a = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->pointing_b);
          this->__isset.pointing_b = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->pointing_c);
          this->__isset.pointing_c = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MountStatus::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("MountStatus");

  xfer += oprot->writeFieldBegin("target_system", ::apache::thrift::protocol::T_BYTE, 1);
  xfer += oprot->writeByte(this->target_system);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("target_component", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte(this->target_component);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pointing_a", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->pointing_a);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pointing_b", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->pointing_b);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pointing_c", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->pointing_c);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MountStatus &a, MountStatus &b) {
  using ::std::swap;
  swap(a.target_system, b.target_system);
  swap(a.target_component, b.target_component);
  swap(a.pointing_a, b.pointing_a);
  swap(a.pointing_b, b.pointing_b);
  swap(a.pointing_c, b.pointing_c);
  swap(a.__isset, b.__isset);
}

const char* FencePoint::ascii_fingerprint = "3EF1C2D1744B1D414EC6041007395D44";
const uint8_t FencePoint::binary_fingerprint[16] = {0x3E,0xF1,0xC2,0xD1,0x74,0x4B,0x1D,0x41,0x4E,0xC6,0x04,0x10,0x07,0x39,0x5D,0x44};

uint32_t FencePoint::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->target_system);
          this->__isset.target_system = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->target_component);
          this->__isset.target_component = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->idx);
          this->__isset.idx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->count);
          this->__isset.count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->lat);
          this->__isset.lat = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->lng);
          this->__isset.lng = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FencePoint::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("FencePoint");

  xfer += oprot->writeFieldBegin("target_system", ::apache::thrift::protocol::T_BYTE, 1);
  xfer += oprot->writeByte(this->target_system);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("target_component", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte(this->target_component);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("idx", ::apache::thrift::protocol::T_BYTE, 3);
  xfer += oprot->writeByte(this->idx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("count", ::apache::thrift::protocol::T_BYTE, 4);
  xfer += oprot->writeByte(this->count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lat", ::apache::thrift::protocol::T_DOUBLE, 5);
  xfer += oprot->writeDouble(this->lat);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lng", ::apache::thrift::protocol::T_DOUBLE, 6);
  xfer += oprot->writeDouble(this->lng);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FencePoint &a, FencePoint &b) {
  using ::std::swap;
  swap(a.target_system, b.target_system);
  swap(a.target_component, b.target_component);
  swap(a.idx, b.idx);
  swap(a.count, b.count);
  swap(a.lat, b.lat);
  swap(a.lng, b.lng);
  swap(a.__isset, b.__isset);
}

const char* FenceFetchPoint::ascii_fingerprint = "0A77C25C826CC107FD266A55D263629B";
const uint8_t FenceFetchPoint::binary_fingerprint[16] = {0x0A,0x77,0xC2,0x5C,0x82,0x6C,0xC1,0x07,0xFD,0x26,0x6A,0x55,0xD2,0x63,0x62,0x9B};

uint32_t FenceFetchPoint::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->target_system);
          this->__isset.target_system = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->target_component);
          this->__isset.target_component = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->idx);
          this->__isset.idx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FenceFetchPoint::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("FenceFetchPoint");

  xfer += oprot->writeFieldBegin("target_system", ::apache::thrift::protocol::T_BYTE, 1);
  xfer += oprot->writeByte(this->target_system);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("target_component", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte(this->target_component);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("idx", ::apache::thrift::protocol::T_BYTE, 3);
  xfer += oprot->writeByte(this->idx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FenceFetchPoint &a, FenceFetchPoint &b) {
  using ::std::swap;
  swap(a.target_system, b.target_system);
  swap(a.target_component, b.target_component);
  swap(a.idx, b.idx);
  swap(a.__isset, b.__isset);
}

const char* FenceStatus::ascii_fingerprint = "5E6FF8125CECA269AA6CCB2477354F05";
const uint8_t FenceStatus::binary_fingerprint[16] = {0x5E,0x6F,0xF8,0x12,0x5C,0xEC,0xA2,0x69,0xAA,0x6C,0xCB,0x24,0x77,0x35,0x4F,0x05};

uint32_t FenceStatus::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->breach_status);
          this->__isset.breach_status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->breach_count);
          this->__isset.breach_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->breach_type);
          this->__isset.breach_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->breach_time);
          this->__isset.breach_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FenceStatus::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("FenceStatus");

  xfer += oprot->writeFieldBegin("breach_status", ::apache::thrift::protocol::T_BYTE, 1);
  xfer += oprot->writeByte(this->breach_status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("breach_count", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16(this->breach_count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("breach_type", ::apache::thrift::protocol::T_BYTE, 3);
  xfer += oprot->writeByte(this->breach_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("breach_time", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->breach_time);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FenceStatus &a, FenceStatus &b) {
  using ::std::swap;
  swap(a.breach_status, b.breach_status);
  swap(a.breach_count, b.breach_count);
  swap(a.breach_type, b.breach_type);
  swap(a.breach_time, b.breach_time);
  swap(a.__isset, b.__isset);
}

const char* Ahrs::ascii_fingerprint = "99DE29E186210BDC0E574B6C449411C5";
const uint8_t Ahrs::binary_fingerprint[16] = {0x99,0xDE,0x29,0xE1,0x86,0x21,0x0B,0xDC,0x0E,0x57,0x4B,0x6C,0x44,0x94,0x11,0xC5};

uint32_t Ahrs::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->omegaIx);
          this->__isset.omegaIx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->omegaIy);
          this->__isset.omegaIy = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->omegaIz);
          this->__isset.omegaIz = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->accel_weight);
          this->__isset.accel_weight = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->renorm_val);
          this->__isset.renorm_val = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->error_rp);
          this->__isset.error_rp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->error_yaw);
          this->__isset.error_yaw = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Ahrs::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Ahrs");

  xfer += oprot->writeFieldBegin("omegaIx", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->omegaIx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("omegaIy", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->omegaIy);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("omegaIz", ::apache::thrift::protocol::T_DOUBLE, 3);
  xfer += oprot->writeDouble(this->omegaIz);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("accel_weight", ::apache::thrift::protocol::T_DOUBLE, 4);
  xfer += oprot->writeDouble(this->accel_weight);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("renorm_val", ::apache::thrift::protocol::T_DOUBLE, 5);
  xfer += oprot->writeDouble(this->renorm_val);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("error_rp", ::apache::thrift::protocol::T_DOUBLE, 6);
  xfer += oprot->writeDouble(this->error_rp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("error_yaw", ::apache::thrift::protocol::T_DOUBLE, 7);
  xfer += oprot->writeDouble(this->error_yaw);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Ahrs &a, Ahrs &b) {
  using ::std::swap;
  swap(a.omegaIx, b.omegaIx);
  swap(a.omegaIy, b.omegaIy);
  swap(a.omegaIz, b.omegaIz);
  swap(a.accel_weight, b.accel_weight);
  swap(a.renorm_val, b.renorm_val);
  swap(a.error_rp, b.error_rp);
  swap(a.error_yaw, b.error_yaw);
  swap(a.__isset, b.__isset);
}

const char* Simstate::ascii_fingerprint = "947C77F4BACE8131560C689714650227";
const uint8_t Simstate::binary_fingerprint[16] = {0x94,0x7C,0x77,0xF4,0xBA,0xCE,0x81,0x31,0x56,0x0C,0x68,0x97,0x14,0x65,0x02,0x27};

uint32_t Simstate::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->roll);
          this->__isset.roll = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->pitch);
          this->__isset.pitch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->yaw);
          this->__isset.yaw = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->xacc);
          this->__isset.xacc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->yacc);
          this->__isset.yacc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->zacc);
          this->__isset.zacc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->xgyro);
          this->__isset.xgyro = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->ygyro);
          this->__isset.ygyro = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->zgyro);
          this->__isset.zgyro = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->lat);
          this->__isset.lat = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->lng);
          this->__isset.lng = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Simstate::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Simstate");

  xfer += oprot->writeFieldBegin("roll", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->roll);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pitch", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->pitch);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("yaw", ::apache::thrift::protocol::T_DOUBLE, 3);
  xfer += oprot->writeDouble(this->yaw);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("xacc", ::apache::thrift::protocol::T_DOUBLE, 4);
  xfer += oprot->writeDouble(this->xacc);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("yacc", ::apache::thrift::protocol::T_DOUBLE, 5);
  xfer += oprot->writeDouble(this->yacc);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("zacc", ::apache::thrift::protocol::T_DOUBLE, 6);
  xfer += oprot->writeDouble(this->zacc);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("xgyro", ::apache::thrift::protocol::T_DOUBLE, 7);
  xfer += oprot->writeDouble(this->xgyro);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ygyro", ::apache::thrift::protocol::T_DOUBLE, 8);
  xfer += oprot->writeDouble(this->ygyro);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("zgyro", ::apache::thrift::protocol::T_DOUBLE, 9);
  xfer += oprot->writeDouble(this->zgyro);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lat", ::apache::thrift::protocol::T_DOUBLE, 10);
  xfer += oprot->writeDouble(this->lat);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lng", ::apache::thrift::protocol::T_DOUBLE, 11);
  xfer += oprot->writeDouble(this->lng);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Simstate &a, Simstate &b) {
  using ::std::swap;
  swap(a.roll, b.roll);
  swap(a.pitch, b.pitch);
  swap(a.yaw, b.yaw);
  swap(a.xacc, b.xacc);
  swap(a.yacc, b.yacc);
  swap(a.zacc, b.zacc);
  swap(a.xgyro, b.xgyro);
  swap(a.ygyro, b.ygyro);
  swap(a.zgyro, b.zgyro);
  swap(a.lat, b.lat);
  swap(a.lng, b.lng);
  swap(a.__isset, b.__isset);
}

const char* Hwstatus::ascii_fingerprint = "2F32B8B152B4427223DB9D670291659B";
const uint8_t Hwstatus::binary_fingerprint[16] = {0x2F,0x32,0xB8,0xB1,0x52,0xB4,0x42,0x72,0x23,0xDB,0x9D,0x67,0x02,0x91,0x65,0x9B};

uint32_t Hwstatus::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->Vcc);
          this->__isset.Vcc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->I2Cerr);
          this->__isset.I2Cerr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Hwstatus::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Hwstatus");

  xfer += oprot->writeFieldBegin("Vcc", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->Vcc);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("I2Cerr", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte(this->I2Cerr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Hwstatus &a, Hwstatus &b) {
  using ::std::swap;
  swap(a.Vcc, b.Vcc);
  swap(a.I2Cerr, b.I2Cerr);
  swap(a.__isset, b.__isset);
}

const char* Radio::ascii_fingerprint = "42B01CAA48C5DE54AA41CC15B4458FCB";
const uint8_t Radio::binary_fingerprint[16] = {0x42,0xB0,0x1C,0xAA,0x48,0xC5,0xDE,0x54,0xAA,0x41,0xCC,0x15,0xB4,0x45,0x8F,0xCB};

uint32_t Radio::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->rssi);
          this->__isset.rssi = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->remrssi);
          this->__isset.remrssi = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->txbuf);
          this->__isset.txbuf = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->noise);
          this->__isset.noise = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->remnoise);
          this->__isset.remnoise = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->rxerrors);
          this->__isset.rxerrors = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->fixed);
          this->__isset.fixed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Radio::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Radio");

  xfer += oprot->writeFieldBegin("rssi", ::apache::thrift::protocol::T_BYTE, 1);
  xfer += oprot->writeByte(this->rssi);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("remrssi", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte(this->remrssi);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("txbuf", ::apache::thrift::protocol::T_BYTE, 3);
  xfer += oprot->writeByte(this->txbuf);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("noise", ::apache::thrift::protocol::T_BYTE, 4);
  xfer += oprot->writeByte(this->noise);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("remnoise", ::apache::thrift::protocol::T_BYTE, 5);
  xfer += oprot->writeByte(this->remnoise);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rxerrors", ::apache::thrift::protocol::T_I16, 6);
  xfer += oprot->writeI16(this->rxerrors);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fixed", ::apache::thrift::protocol::T_I16, 7);
  xfer += oprot->writeI16(this->fixed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Radio &a, Radio &b) {
  using ::std::swap;
  swap(a.rssi, b.rssi);
  swap(a.remrssi, b.remrssi);
  swap(a.txbuf, b.txbuf);
  swap(a.noise, b.noise);
  swap(a.remnoise, b.remnoise);
  swap(a.rxerrors, b.rxerrors);
  swap(a.fixed, b.fixed);
  swap(a.__isset, b.__isset);
}

const char* LimitsStatus::ascii_fingerprint = "40669755E299B2DA8CA63E09C75EF4A4";
const uint8_t LimitsStatus::binary_fingerprint[16] = {0x40,0x66,0x97,0x55,0xE2,0x99,0xB2,0xDA,0x8C,0xA6,0x3E,0x09,0xC7,0x5E,0xF4,0xA4};

uint32_t LimitsStatus::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->limits_state);
          this->__isset.limits_state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->last_trigger);
          this->__isset.last_trigger = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->last_action);
          this->__isset.last_action = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->last_recovery);
          this->__isset.last_recovery = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->last_clear);
          this->__isset.last_clear = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->breach_count);
          this->__isset.breach_count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->mods_enabled);
          this->__isset.mods_enabled = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->mods_required);
          this->__isset.mods_required = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->mods_triggered);
          this->__isset.mods_triggered = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t LimitsStatus::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("LimitsStatus");

  xfer += oprot->writeFieldBegin("limits_state", ::apache::thrift::protocol::T_BYTE, 1);
  xfer += oprot->writeByte(this->limits_state);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("last_trigger", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->last_trigger);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("last_action", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->last_action);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("last_recovery", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->last_recovery);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("last_clear", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->last_clear);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("breach_count", ::apache::thrift::protocol::T_I16, 6);
  xfer += oprot->writeI16(this->breach_count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mods_enabled", ::apache::thrift::protocol::T_BYTE, 7);
  xfer += oprot->writeByte(this->mods_enabled);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mods_required", ::apache::thrift::protocol::T_BYTE, 8);
  xfer += oprot->writeByte(this->mods_required);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mods_triggered", ::apache::thrift::protocol::T_BYTE, 9);
  xfer += oprot->writeByte(this->mods_triggered);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LimitsStatus &a, LimitsStatus &b) {
  using ::std::swap;
  swap(a.limits_state, b.limits_state);
  swap(a.last_trigger, b.last_trigger);
  swap(a.last_action, b.last_action);
  swap(a.last_recovery, b.last_recovery);
  swap(a.last_clear, b.last_clear);
  swap(a.breach_count, b.breach_count);
  swap(a.mods_enabled, b.mods_enabled);
  swap(a.mods_required, b.mods_required);
  swap(a.mods_triggered, b.mods_triggered);
  swap(a.__isset, b.__isset);
}

const char* Wind::ascii_fingerprint = "EFFAD640FBA2CA56C50155B2A4545897";
const uint8_t Wind::binary_fingerprint[16] = {0xEF,0xFA,0xD6,0x40,0xFB,0xA2,0xCA,0x56,0xC5,0x01,0x55,0xB2,0xA4,0x54,0x58,0x97};

uint32_t Wind::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->direction);
          this->__isset.direction = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->speed);
          this->__isset.speed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->speed_z);
          this->__isset.speed_z = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Wind::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Wind");

  xfer += oprot->writeFieldBegin("direction", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->direction);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("speed", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->speed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("speed_z", ::apache::thrift::protocol::T_DOUBLE, 3);
  xfer += oprot->writeDouble(this->speed_z);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Wind &a, Wind &b) {
  using ::std::swap;
  swap(a.direction, b.direction);
  swap(a.speed, b.speed);
  swap(a.speed_z, b.speed_z);
  swap(a.__isset, b.__isset);
}

const char* Data16::ascii_fingerprint = "A620FE562121E92527503224024A152E";
const uint8_t Data16::binary_fingerprint[16] = {0xA6,0x20,0xFE,0x56,0x21,0x21,0xE9,0x25,0x27,0x50,0x32,0x24,0x02,0x4A,0x15,0x2E};

uint32_t Data16::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->data16_type);
          this->__isset.data16_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->len);
          this->__isset.len = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->data.clear();
            uint32_t _size0;
            ::apache::thrift::protocol::TType _etype3;
            xfer += iprot->readListBegin(_etype3, _size0);
            this->data.resize(_size0);
            uint32_t _i4;
            for (_i4 = 0; _i4 < _size0; ++_i4)
            {
              xfer += iprot->readByte(this->data[_i4]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Data16::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Data16");

  xfer += oprot->writeFieldBegin("data16_type", ::apache::thrift::protocol::T_BYTE, 1);
  xfer += oprot->writeByte(this->data16_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("len", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte(this->len);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_BYTE, static_cast<uint32_t>(this->data.size()));
    std::vector<int8_t> ::const_iterator _iter5;
    for (_iter5 = this->data.begin(); _iter5 != this->data.end(); ++_iter5)
    {
      xfer += oprot->writeByte((*_iter5));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Data16 &a, Data16 &b) {
  using ::std::swap;
  swap(a.data16_type, b.data16_type);
  swap(a.len, b.len);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

const char* Data32::ascii_fingerprint = "A620FE562121E92527503224024A152E";
const uint8_t Data32::binary_fingerprint[16] = {0xA6,0x20,0xFE,0x56,0x21,0x21,0xE9,0x25,0x27,0x50,0x32,0x24,0x02,0x4A,0x15,0x2E};

uint32_t Data32::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->data32_type);
          this->__isset.data32_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->len);
          this->__isset.len = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->data.clear();
            uint32_t _size6;
            ::apache::thrift::protocol::TType _etype9;
            xfer += iprot->readListBegin(_etype9, _size6);
            this->data.resize(_size6);
            uint32_t _i10;
            for (_i10 = 0; _i10 < _size6; ++_i10)
            {
              xfer += iprot->readByte(this->data[_i10]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Data32::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Data32");

  xfer += oprot->writeFieldBegin("data32_type", ::apache::thrift::protocol::T_BYTE, 1);
  xfer += oprot->writeByte(this->data32_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("len", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte(this->len);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_BYTE, static_cast<uint32_t>(this->data.size()));
    std::vector<int8_t> ::const_iterator _iter11;
    for (_iter11 = this->data.begin(); _iter11 != this->data.end(); ++_iter11)
    {
      xfer += oprot->writeByte((*_iter11));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Data32 &a, Data32 &b) {
  using ::std::swap;
  swap(a.data32_type, b.data32_type);
  swap(a.len, b.len);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

const char* Data64::ascii_fingerprint = "A620FE562121E92527503224024A152E";
const uint8_t Data64::binary_fingerprint[16] = {0xA6,0x20,0xFE,0x56,0x21,0x21,0xE9,0x25,0x27,0x50,0x32,0x24,0x02,0x4A,0x15,0x2E};

uint32_t Data64::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->data64_type);
          this->__isset.data64_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->len);
          this->__isset.len = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->data.clear();
            uint32_t _size12;
            ::apache::thrift::protocol::TType _etype15;
            xfer += iprot->readListBegin(_etype15, _size12);
            this->data.resize(_size12);
            uint32_t _i16;
            for (_i16 = 0; _i16 < _size12; ++_i16)
            {
              xfer += iprot->readByte(this->data[_i16]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Data64::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Data64");

  xfer += oprot->writeFieldBegin("data64_type", ::apache::thrift::protocol::T_BYTE, 1);
  xfer += oprot->writeByte(this->data64_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("len", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte(this->len);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_BYTE, static_cast<uint32_t>(this->data.size()));
    std::vector<int8_t> ::const_iterator _iter17;
    for (_iter17 = this->data.begin(); _iter17 != this->data.end(); ++_iter17)
    {
      xfer += oprot->writeByte((*_iter17));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Data64 &a, Data64 &b) {
  using ::std::swap;
  swap(a.data64_type, b.data64_type);
  swap(a.len, b.len);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

const char* Data96::ascii_fingerprint = "A620FE562121E92527503224024A152E";
const uint8_t Data96::binary_fingerprint[16] = {0xA6,0x20,0xFE,0x56,0x21,0x21,0xE9,0x25,0x27,0x50,0x32,0x24,0x02,0x4A,0x15,0x2E};

uint32_t Data96::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->data96_type);
          this->__isset.data96_type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BYTE) {
          xfer += iprot->readByte(this->len);
          this->__isset.len = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->data.clear();
            uint32_t _size18;
            ::apache::thrift::protocol::TType _etype21;
            xfer += iprot->readListBegin(_etype21, _size18);
            this->data.resize(_size18);
            uint32_t _i22;
            for (_i22 = 0; _i22 < _size18; ++_i22)
            {
              xfer += iprot->readByte(this->data[_i22]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Data96::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Data96");

  xfer += oprot->writeFieldBegin("data96_type", ::apache::thrift::protocol::T_BYTE, 1);
  xfer += oprot->writeByte(this->data96_type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("len", ::apache::thrift::protocol::T_BYTE, 2);
  xfer += oprot->writeByte(this->len);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_BYTE, static_cast<uint32_t>(this->data.size()));
    std::vector<int8_t> ::const_iterator _iter23;
    for (_iter23 = this->data.begin(); _iter23 != this->data.end(); ++_iter23)
    {
      xfer += oprot->writeByte((*_iter23));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Data96 &a, Data96 &b) {
  using ::std::swap;
  swap(a.data96_type, b.data96_type);
  swap(a.len, b.len);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

const char* Rangefinder::ascii_fingerprint = "EA2086D2BB14222991D7B0497DE7B58B";
const uint8_t Rangefinder::binary_fingerprint[16] = {0xEA,0x20,0x86,0xD2,0xBB,0x14,0x22,0x29,0x91,0xD7,0xB0,0x49,0x7D,0xE7,0xB5,0x8B};

uint32_t Rangefinder::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->distance);
          this->__isset.distance = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->voltage);
          this->__isset.voltage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Rangefinder::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("Rangefinder");

  xfer += oprot->writeFieldBegin("distance", ::apache::thrift::protocol::T_DOUBLE, 1);
  xfer += oprot->writeDouble(this->distance);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("voltage", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->voltage);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Rangefinder &a, Rangefinder &b) {
  using ::std::swap;
  swap(a.distance, b.distance);
  swap(a.voltage, b.voltage);
  swap(a.__isset, b.__isset);
}

}} // namespace
